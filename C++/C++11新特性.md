#### 1、C++11有哪些新特性？

C++新特性主要包括包含语法改进和标准库扩充两个方面，主要包括以下11点：

一、语法的改进

1. 统一的初始化方法---------使用初始化列表进行初始化（适用性被增加，现可以用于任何类型对象的初始化）
2. 成员变量默认初始化
3. auto 关键字 用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）
4. decltype 求表达式的类型
5. 智能指针 shared_ptr
6. 空指针 nullptr（原来NULL）
7. 基于范围的 for 循环
8. 右值引用和 move 语义 让程序员有意识减少进行深拷贝操作

二、标准库扩充

1. 无序容器（哈希表） 用法和功能同 map 一模一样，区别在于哈希表的效率更高
2. 正则表达式 可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串
3. Lambda 表达式

#### 2、说一说你了解的关于lambda函数的全部知识

- ① **利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象；**
- ② **每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类当然重载了()运算符），我们称为闭包类型（closure type）。**那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，其实一个右值。所以，我们上面的lambda表达式的结果就是一个个闭包。闭包的一个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们又将其称为lambda捕捉块。
- ③ lambda表达式的语法定义如下：`[capture] (parameters) mutable ->return-type {statement};`
- ④ 与普通函数不同，lambda必须使用尾置返回来指定返回类型
- ⑤ 我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体

#### 3、**C++中NULL和nullptr区别**

**在C++中指针必须有明确的类型定义。但是将NULL定义为0带来的另一个问题是无法与整数的0区分。**

由于在**传入NULL参数时，会把NULL当做整数0来看，如果我们想调用参数是指针的函数**，该怎么办呢?nullptr在C++11被引入用于解决这一问题，**nullptr可以明确区分整型和指针类型**，**能够根据环境自动转换成相应的指针类型**，但不会被转换为任何整型，所以不会造成参数传递错误。

#### 4、**auto、decltype和decltype(auto)的用法**

1）auto 

**auto用于定义变量，编译器可以自动判断变量的类型。auto 让编译器通过初始值来进行类型推演**。从而获得定义变量的类型，所以说 auto 定义的变量必须有初始值。

**auto和 const 的结合使用**

a. 当类型不为引用时，auto 的推导结果将不保留表达式的 const 属性；

b. 当类型为引用时，auto 的推导结果将保留表达式的 const 属性。

使用auto定义迭代器比较方便

2）decltype

有的时候我们还会遇到这种情况，我们希望从表达式中推断出要定义变量的类型，但却不想用表达式的值去初始化变量。还有可能是**函数的返回类型为某表达式的值类型**。在这些时候auto显得就无力了，所以C++11又引入了第二种类型说明符**decltype，它的作用是选择并返回操作数的数据类型。**在此过程中，编译器只是分析表达式并得到它的类型，却不进行实际的计算表达式的值。

3）decltype(auto)

decltype(auto)是C++14新增的类型指示符，**可以用来声明变量以及指示函数返回类型**。在使用时，会将“=”号左边的表达式替换掉auto，再根据decltype的语法规则来确定类型。

#### 5、**说说 C++ 中智能指针和指针的区别是什么？**

智能指针和普通指针的区别在于智能指针实际上是对普通指针加了一层封装机制，区别是它负责自动释放所指的对象，这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期。

#### 6、说说C++中的智能指针有哪些？分别解决的问题以及区别？

1. C++中的智能指针有4种，分别为：shared_ptr、unique_ptr、weak_ptr、auto_ptr，其中，auto_ptr被C++11弃用。

2. 使用智能指针的原因

- 申请的空间（即new出来的空间），在使用结束时，需要delete掉，否则会形成内存碎片。在程序运行期间，new出来的对象，在析构函数中delete掉，但是这种方法不能解决所有问题，因为有时候new发生在某个全局函数里面，该方法会给程序员造成精神负担。此时，智能指针就派上了用场。使用智能指针可以很大程度上避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源。所以，智能指针的作用原理就是在函数结束时自动释放内存空间，避免了手动释放内存空间。

3. 四种指针分别解决的问题以及各自特性如下：

（1）auto_ptr（C++98的方案，C++11已经弃用）

- 采用所有权模式。

（2）unique_ptr（替换auto_ptr）

- unique_ptr实现独占式拥有或严格拥有概念，**保证同一时间内只有一个智能指针可以指向该对象**。它对于避免资源泄露，例如，以new创建对象后因为发生异常而忘记调用delete时的情形特别有用。

（3）shared_ptr（非常好使）

- shared_ptr实现共享式拥有概念。**多个智能指针可以指向相同对象**，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。

（4）weak_ptr

- weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象。进行该对象的内存管理的是那个强引用的 shared_ptr。weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作，它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用计数的增加或减少。**weak_ptr是用来解决shared_ptr相互引用时的死锁问题**，**如果说两个shared_ptr相互引用，那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。**它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化。shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。

#### 7、**使用智能指针管理内存资源，RAII是怎么回事？**

① RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”，也就是说在构造函数中申请分配资源，在析构函数中释放资源。

因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。

② 智能指针（std::shared_ptr和std::unique_ptr）即RAII最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏。

毫不夸张的来讲，有了智能指针，代码中几乎不需要再出现delete了。

#### 8、**智能指针的作用**

C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。

**初始化。智能指针是个模板类，可以指定类型，传入指针通过构造函数初始化**。也可以使用make_shared函数初始化。**不能将指针直接赋值给一个智能指针，一个是类，一个是指针。**例如std::shared_ptr<int> p4 = new int(1);的写法是错误的

**拷贝和赋值。拷贝使得对象的引用计数增加1，赋值使得原对象引用计数减1**，当计数为0时，自动释放内存。后来指向的对象引用计数加1，指向后来的对象

**unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）**。相比与原始指针unique_ptr用于其RAII的特性，使得在出现异常的情况下，动态资源能得到释放。unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。unique_ptr指针与其所指对象的关系：在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权。

weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, **它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少**。

#### 9、**智能指针的循环引用**

循环引用是指使用多个智能指针share_ptr时，出现了指针之间相互指向，从而形成环的情况，有点类似于死锁的情况，这种情况下，智能指针往往不能正常调用对象的析构函数，从而造成内存泄漏。

在实际编程过程中，应该尽量避免出现智能指针之前相互指向的情况，如果不可避免，可以使用使用弱指针——weak_ptr，它不增加引用计数，只要出了作用域就会自动析构。

#### 10、**智能指针出现循环引用怎么解决？**

为了解决循环引用导致的内存泄漏，引入了弱指针weak_ptr，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但是不会指向引用计数的共享内存，但是可以检测到所管理的对象是否已经被释放，从而避免非法访问。

#### 11、**share_****ptr** **怎么知道跟它共享对象的指针释放了**

多个shared_ptr对象可以同时托管一个指针，系统会维护一个托管计数。当无shared_ptr托管该指针时，delete该指针。

#### 12、**手写实现智能指针类需要实现哪些函数？**

智能指针是一个数据类型，一般用模板实现，模拟指针行为的同时还提供自动垃圾回收机制。它会自动记录SmartPointer<T*>对象的引用计数，一旦T类型对象的引用计数为0，就释放该对象。

除了指针对象外，我们还需要一个引用计数的指针设定对象的值，并将引用计数计为1，需要一个构造函数。新增对象还需要一个构造函数，析构函数负责引用计数减少和释放内存。

通过**覆写赋值运算符**，才能将一个旧的智能指针赋值给另一个指针，同时旧的引用计数减1，新的引用计数加1

**一个构造函数、拷贝构造函数、复制构造函数、析构函数、移动函数；**

#### 13、**weak_****ptr** **能不能知道对象计数为 0，为什么？**

不能。

weak_ptr是一种不控制对象生命周期的智能指针，它指向一个shared_ptr管理的对象。进行该对象管理的是那个引用的shared_ptr。weak_ptr只是提供了对管理 对象的一个访问手段。weak_ptr设计的目的只是为了配合shared_ptr而引入的一种智能指针，配合shared_ptr工作，它只可以从一个shared_ptr或者另一个weak_ptr对象构造，**它的构造和析构不会引起计数的增加或减少。**

#### 14、**请你回答一下智能指针有没有内存泄露的情况**

**智能指针有内存泄露的情况发生。**

1. 智能指针发生内存泄露的情况
   - 当两个对象同时使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄露。

2. 智能指针的内存泄漏如何解决？
   - 为了解决循环引用导致的内存泄漏，引入了弱指针weak_ptr，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但是不会指向引用计数的共享内存，但是可以检测到所管理的对象是否已经被释放，从而避免非法访问。

#### 15、**说说你了解的auto_ptr作用**

auto_ptr的出现，主要是为了解决“**有异常抛出时发生内存泄漏**”的问题；抛出异常，将导致指针p所指向的空间得不到释放而导致内存泄漏；

auto_ptr的构造函数是explicit，阻止了一般指针隐式转换为 auto_ptr的构造，所以不能直接将一般类型的指针赋值给auto_ptr类型的对象，必须用auto_ptr的构造函数创建对象；

由于auto_ptr对象析构时会删除它所拥有的指针，所以使用时避免多个auto_ptr对象管理同一个指针；

auto_ptr内部实现，析构函数中删除对象用的是delete而不是delete[]，所以auto_ptr不能管理数组；

auto_ptr支持所拥有的指针类型之间的隐式类型转换。

可以通过*和->运算符对auto_ptr所有用的指针进行提领操作；

T* get(),获得auto_ptr所拥有的指针；T* release()，释放auto_ptr的所有权，并将所有用的指针返回。

#### 16、**简述 C++ 右值引用与转移语义**

1. 右值引用

一般来说，不能取地址的表达式，就是右值引用，能取地址的，就是左值。

2. 转移语义

move 本意为 "移动"，但该函数并不能移动任何数据，它的功能很简单，就是将某个左值强制转化为右值。基于 move() 函数特殊的功能，其常用于实现移动语义。

#### 17、**说一下C++左值引用和右值引用**

C++11正是通过引入右值引用来优化性能，具体来说是通过移动语义来避免无谓拷贝的问题，通过move语义来将临时生成的左值中的资源无代价的转移到另外一个对象中去，通过完美转发来解决不能按照参数实际类型来转发的问题（同时，完美转发获得的一个好处是可以实现移动语义）。

① 在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值。在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。

② C++11对C++98中的右值进行了扩充。在C++11中右值又分为纯右值（prvalue，Pure Rvalue）和将亡值（xvalue，eXpiring Value）。其中纯右值的概念等同于我们在C++98标准中右值的概念，指的是临时变量和不跟对象关联的字面量值；将亡值则是C++11新增的跟右值引用相关的表达式，这样表达式通常是将要被移动的对象（移为他用），比如返回右值引用T&&的函数返回值、std::move的返回值，或者转换为T&&的类型转换函数的返回值。

③ 左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值进行引用的类型，事实上，由于**右值通常不具有名字**，我们也只能通过引用的方式找到它的存在。右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。但常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值只能接受非常量左值对其进行初始化。

④ 右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值。

**左值和右值**

左值：表示的是可以获取地址的表达式，它能出现在赋值语句的左边，对该表达式进行赋值。但是修饰符const的出现使得可以声明如下的标识符，它可以取得地址，但是没办法对其进行赋值

右值：表示无法获取地址的对象，有常量值、函数返回值、lambda表达式等。无法获取地址，但不表示其不可改变，当定义了右值的右值引用时就可以更改右值。

**左值引用和右值引用**

左值引用：传统的C++中引用被称为左值引用

右值引用：C++11中增加了右值引用，右值引用关联到右值时，右值被存储到特定位置，右值引用指向该特定位置，也就是说，右值虽然无法获取地址，但是右值引用是可以获取地址的，该地址表示临时对象的存储位置

这里主要说一下右值引用的特点：

特点1：通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去

特点2：右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值

特点3：T&& t在发生自动类型推断的时候，它是左值还是右值取决于它的初始化。

#### 18、**简述一下 C++11 中四种类型转换**

C++中四种类型转换分别为const_cast、static_cast、dynamic_cast、reinterpret_cast。

**1. const_cast**

将const变量转为非const

**2. static_cast**

最常用，可以用于各种隐式转换，比如非const转const，static_cast可以用于类向上转换，但向下转换能成功但是不安全。

**3. dynamic_cast**

**只能用于含有虚函数的类转换，用于类向上和向下转换**

向上转换：指子类向基类转换。

向下转换：指基类向子类转换。

这两种转换，子类包含父类，当父类转换成子类时可能出现非法内存访问的问题。

**dynamic_cast通过判断变量运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。**dynamic_cast可以做类之间上下转换，转换的时候会进行类型检查，类型相等成功转换，类型不等转换失败。运用RTTI技术，RTTI是”Runtime Type Information”的缩写，意思是运行时类型信息，它提供了运行时确定对象类型的方法。在c++层面主要体现在dynamic_cast和typeid，vs中虚函数表的-1位置存放了指向type_info的指针，对于存在虚函数的类型，dynamic_cast和typeid都会去查询type_info。

**4. reinterpret_cast**

**reinterpret_cast可以做任何类型的转换，不过不对转换结果保证，容易出问题。**

注意：为什么不用C的强制转换：C的强制转换表面上看起来功能强大什么都能转，但是转换不够明确，不能进行错误检查，容易出错。

#### 19、**简述一下 C++11 中的可变参数模板新特性**

可变参数模板(variadic template)使得编程者能够创建可接受可变数量的参数模板类。

要创建可变参数模板，需要理解几个要点：

（1）模板参数包（parameter pack）；

（2）函数参数包；

（3）展开（unpack）参数包；

（4）递归。

#### 20、**static_cast比C语言中的转换强在哪里？**

更加安全；

更直接明显，能够一眼看出是什么类型转换为什么类型，容易找出程序中的错误；可清楚地辨别代码中每个显式的强制转；可读性更好，能体现程序员的意图