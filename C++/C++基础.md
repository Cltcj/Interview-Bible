### 一、C++语言基础

#### 1、main函数的返回值有什么值得考究之处吗？

- 程序运行过程入口点main函数，main()函数返回值类型必须是int，这样返回值才能传递给程序激活者（如操作系统）表示程序正常退出。
- `main(int argc, char **argv)` 参数的传递。参数的处理，一般会调用getopt()函数处理，但实践中，这仅仅是一部分，不会经常用到的技能点。

#### 2、初始化和赋值的区别

- 对于简单类型来说，初始化和赋值没什么区别


- 对于类和复杂数据类型来说，会调用拷贝构造函数


#### 3、变量声明和定义区别？

- 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间，定义要在定义的地方为其分配存储空间。
- 相同变量可以在多处声明（外部变量extern），但只能在一处定义。

#### 4、**定义和声明的区别**

- 如果是指变量的声明和定义： 从编译原理上来说，声明是仅仅告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存。而定义就是分配了内存。
- 如果是指函数的声明和定义： 声明：一般在头文件里，对编译器说：这里我有一个函数叫function() 让编译器知道这个函数的存在。 定义：一般在源文件里，具体就是函数的实现过程写明函数体。

#### 5、strlen和sizeof区别？

- sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。
- sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是'\0'的字符串。
- 因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。

#### 6、volatile、mutable和explicit关键字的用法

**（1）volatile**

- volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。
- volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。**多线程中被几个任务共享的变量需要定义为volatile类型。**该关键字的作用是<u>防止优化编译器把变量从内存装入CPU寄存器中。</u>
- 可以把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象。除了基本类型外，对用户定义类型也可以用volatile类型进行修饰。
- C++中一个有volatile标识符的类只能访问它接口的子集，一个由类的实现者控制的子集。用户只能用const_cast来获得对类型接口的完全访问。此外，volatile向const一样会从类传递到它的成员。
- volatile 指针和 const 修饰词类似，const 有常量指针和指针常量的说法，volatile 也有相应的概念

**（2）mutable**

- mutable的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词。在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被mutable来修饰，并且放在函数后后面关键字位置。


**（3）Explicit**

- explicit关键字用来修饰类的构造函数，<u>被修饰的构造函数的类，不能发生相应的隐式类型转换</u>，只能以显示的方式进行类型转换，注意以下几点：

  - explicit 关键字只能用于类内部的构造函数声明上
  - explicit 关键字**作用于单个参数**的构造函数
  - 被explicit修饰的构造函数的类，不能发生相应的隐式类型转换

#### 7、形参与实参的区别？

1. 形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 函数调用结束返回主调函数后则不能再使用该形参变量。
2. 实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值，会产生一个临时变量。
3. 实参和形参在数量上，类型上，顺序上应严格一致，否则会发生“类型不匹配”的错误。
4. 函数调用中发生的数据传送是单向的。 即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。
5. 当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变。

#### 8、值传递、指针传递、引用传递的区别和效率

- 值传递：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象或是大的结构体对象，将耗费一定的时间和空间。（传值）
- 指针传递：同样有一个形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为4字节的地址。（传值，传递的是地址值）
- 引用传递：同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。（传地址）
- 效率上讲，指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰。

#### 9、**对象复用的了解，零拷贝的了解**

**对象复用：**

- 对象复用其本质是一种设计模式：Flyweight享元模式


- 通过将对象存储到“对象池”中实现对象的重复利用，这样可以避免多次创建对象的开销，节约系统资源。


**零拷贝：**

- 零拷贝就是一种避免CPU将数据从一块存储拷贝到另外一块存储的技术。
- 零拷贝技术可以减少数据拷贝和共享总线操作的次数。
- 在C++中，vector的一个成员函数emplace_back()很好地体现了零拷贝技术，它跟push_back()函数一样可以将一个元素插入到容器尾部，区别在于push_back()函数需要调用拷贝构造函数和转移构造函数，而使用emplace_back()插入的元素原地构造，不需要触发拷贝构造和转移构造，效率更高

#### 10、C++四种强制转换

**reinterpret_cast：**`reinterpret_cast<type-id>(expression)`

- type-id必须是一个指针、引用、算术类型、函数指针或成员指针。它可以用于类型之间进行强制转换。

**const_cast：**`const_cast<type_id>(expression)`

- 该运算符用来修改类型的const或volatile属性。除了const或volatile修饰之外，type_id和expression的类型是一样的。用法如下：
  - 常量指针被转化为非常量的指针，并且仍指向原来的对象
  - 常量引用被转换成非常量的引用，并且仍然指向原来的对象
  - const_cast一般用于修改底指针，如const char* p形式


**static_cast：**`static_cast<type_id>(expression)`

- 该运算符把expression转换为type_id类型，但没有运行时类型检查来保证转换的安全性。用法：
- 用于类层次结构中基类和派生类之间指针或引用的转换
  - 进行上行转换（派生类转换为基类）是安全的
  - 进行下行转换，由于没有动态类型的检查，所以是不安全的
- 用于基本数据类型之间的转换，如int转char，这种转换类型的安全性需要开发人员来保证。
- 把空指针转换为目标类型的空指针
- 把任何类型的表达式转换为void类型

**dynamic_cast：**`dynamic_cast(expression)`

- 有类型检查，基类向派生类转换比较安全，但派生类转基类不太安全
- 该运算符把expression转换成type_id类型的对象。type_id必须是类的指针，类的引用或void*
- 如果type_id是类指针类型，那么expression也必须是一个指针，如果type_id是一个引用，那么expression也必须是一个引用
- dynamic_cast运算符可以在执行期间决定真正的类型，也就是说expression必须是多态类型，如果下行转换是安全的，这个运算符会传回适当转型过的指针。如果下行转换不安全，这个运算符会传回空指针
- dynamic_cast主要用于类层次间的上下行转换，还可以用于类之间的交叉转换
  - 上行和static_cast一样--安全的
  - 下行有类型检查的功能，比static_cast安全

#### 11、**C++函数调用的压栈的过程**

函数调用过程：

1. 栈空间分配存储空间
2. 从实参的存储空间复制到形参的栈空间
3. 进行运算
   - 形参在函数未调用前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间
   - 数组作为参数的函数调用方式是地址传递，形参和实参都是指向相同的内存空间，调用完毕之后形参指针被销毁，但是所指向的内存依旧存在，不能也不会被销毁
   - 当函数有多个返回值时，不能用普通的return方式实现，需要通过传回地址的形式进行，即地址/指针传递

#### 12、写C++代码时有一类错误coredump，很常见，你遇到过吗？怎么调式这个错误？

- coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成一个叫做core的文件，这个文件会记录运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的对栈调试信息。


#### 13、**C++中将临时变量作为返回值时的处理过程**

- 首先需要明白一件事情，临时变量，在函数调用过程中是被压到程序进程的栈中的，当函数退出时，临时变量出栈，即临时变量已经被销毁，<u>临时变量占用的内存空间没有被清空，但是可以被分配给其他变量，所以有可能在函数退出时，该内存已经被修改了，对于临时变量来说已经是没有意义的值了</u>
- C语言里规定：16bit程序中，返回值保存在ax寄存器中，32bit程序中，返回值保持在eax寄存器中，如果是64bit返回值，edx寄存器保存高32bit，eax寄存器保存低32bit
- **函数调用结束后，返回值被临时存储到寄存器中，并没有放到堆或栈中，也就是说与内存没有关系了。当退出函数的时候，临时变量可能被销毁，但是返回值却被放到寄存器中与临时变量的生命周期没有关系。如果我们需要返回值，一般使用赋值语句就可以了。**

#### 14、**如何获得结构成员相对于结构开头的字节偏移量**

- 使用<stddef.h>头文件中的，offsetof宏。


#### 15、**静态类型和动态类型，静态绑定和动态绑定的介绍**

- 静态类型：对象在声明时采用的类型，在编译期既已确定；
- 动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；
- 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；
- 动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；

静态绑定和动态绑定的区别：

- 静态绑定发生在编译期，动态绑定发生在运行期；
- 对象的动态类型可以更改，但是静态类型无法更改；
- 要想实现动态，必须使用动态绑定；
- **在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定；**

#### 16、**你知道静态绑定和动态绑定吗?**

- 对象的静态类型：对象在声明时采用的类型。是在编译期确定的。
- 对象的动态类型：目前所指对象的类型。是在运行期决定的。对象的动态类型可以更改，但是静态类型无法更改。
- 静态绑定：绑定的是对象的静态类型，某特性（比如函数依赖于对象的静态类型，发生在编译期。)
- 动态绑定：绑定的是对象的动态类型，某特性（比如函数依赖于对象的动态类型，发生在运行期。)

#### 17、**引用是否能实现动态绑定，为什么可以实现？**

可以。

- 引用在创建的时候必须初始化，在访问虚函数时，编译器会根据其所绑定的对象类型决定要调用哪个函数。注意只能调用虚函数。需要说明的是<u>虚函数才具有动态绑定</u>


#### 18、**类如何实现只能静态分配和只能动态分配**

- 前者是把new、delete运算符重载为private属性。后者是把构造、析构函数设为protected属性，再用子类来动态创建


**建立类的对象有两种方式：**

1. 静态建立，静态建立一个类对象，就是由编译器为对象在栈空间中分配内存；
2. 动态建立，A *p = new A();动态建立一个类对象，就是使用new运算符为对象在堆空间中分配内存。这个过程分为两步，第一步执行operator new()函数，在堆中搜索一块内存并进行分配；第二步调用类构造函数构造对象；只有使用new运算符，对象才会被建立在堆上，因此只要限制new运算符就可以实现类对象只能建立在栈上，可以将new运算符设为私有。

#### 19、**全局变量和局部变量有什么区别？**

- **生命周期不同：**全局变量随主程序创建而创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；
- **使用方式不同：**通过声明后全局变量在程序的各个部分都可以用到；局部变量分配在堆栈区，只能在局部使用。
- 操作系统和编译器通过内存分配的位置可以区分两者，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面。

#### 20、**怎样判断两个浮点数是否相等？**

- 对两个浮点数判断大小和是否相等不能直接用==来判断，会出错！明明相等的两个数比较反而是不相等！**对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值！**浮点数与0的比较也应该注意。与浮点数的表示方式有关。


#### 21、nullptr调用成员函数可以吗？为什么？

- 能，因为在**编译时对象**就绑定了**函数地址**，和指针空不空没关系。

#### 22、**你知道重载运算符吗？**

1. 我们只能重载已有的运算符，而无权发明新的运算符；对于一个重载的运算符，其优先级和结合律与内置类型一致才可以；不能改变运算符操作数个数；
2.  两种重载方式：<u>成员运算符和非成员运算符</u>，成员运算符比非成员运算符少一个参数；下标运算符、箭头运算符必须是成员运算符；
3. 引入运算符重载，是为了实现类的多态性；
4. **当重载的运算符是成员函数时，this绑定到左侧运算符对象。成员运算符函数的参数数量比运算符对象的数量少一个；至少含有一个类类型的参数；**
5. 从参数的个数推断到底定义的是哪种运算符，当运算符既是一元运算符又是二元运算符（+，-，*，&）；
6.  下标运算符必须是成员函数，下标运算符通常以所访问元素的引用作为返回值，同时最好定义下标运算符的常量版本和非常量版本；
7. 箭头运算符必须是类的成员，解引用通常也是类的成员；重载的箭头运算符必须返回类的指针；

#### 23、**当程序中有函数重载时，函数的匹配原则和顺序是什么？**

1. 名字查找
2. 确定候选函数
3. 寻找最佳匹配

#### 24、**函数调用过程栈的变化，返回值和参数变量哪个先入栈？**

1. 按照形参顺序相反的顺序压入栈中,**即:从右向左依次把被调函数所需要的参数压入栈**;
2. 调用者函数使用call指令调用被调函数,并把call指令的下一条指令的地址当成返回地址压入栈中(这个压栈操作隐含在call指令中);
3. 在被调函数中,被调函数会先保存调用者函数的栈底地址(push ebp),然后再保存调用者函数的栈顶地址,即:当前被调函数的栈底地址(mov ebp,esp)，在被调函数中,从ebp的位置处开始存放被调函数中的局部变量和临时变量,并且这些变量的地址按照定义时的顺序依次减小,即:这些变量的地址是按照栈的延伸方向排列的,先定义的变量先入栈,后定义的变量后入栈;

#### 25、**C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？**

1) **指针参数传递本质上是值传递，它所传递的是一个地址值。**
   - 值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。


2) **引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。**
   - 被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。


3) **引用传递和指针传递是不同的，虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。**而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用。
4) **从编译的角度来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。**指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）。

#### 28、你知道printf函数的实现原理是什么吗？

- 在C/C++中，对函数参数的扫描是从后向前的。


- C/C++的函数参数是通过压入堆栈的方式来给函数传参数的（堆栈是一种先进后出的数据结构），最先压入的参数最后出来，在计算机的内存中，数据有2块，一块是堆，一块是栈（函数参数及局部变量在这里），而栈是从内存的高地址向低地址生长的，控制生长的就是堆栈指针了，最先压入的参数是在最上面，就是说在所有参数的最后面，最后压入的参数在最下面，结构上看起来是第一个，所以最后压入的参数总是能够被函数找到，因为它就在堆栈指针的上方。


- **printf的第一个被找到的参数就是那个字符指针，就是被双引号括起来的那一部分，函数通过判断字符串里控制参数的个数来判断参数个数及数据类型，通过这些就可算出数据需要的堆栈指针的偏移量了**

#### 30、方法调用的原理（栈，汇编）

- 机器用栈来传递过程参数、存储返回信息、保存寄存器用于以后恢复，以及本地存储。而为单个过程分配的那部分栈称为帧栈；帧栈可以认为是程序栈的一段，它有两个端点，一个标识起始地址，一个标识着结束地址，两个指针结束地址指针esp，开始地址指针ebp;
- 由一系列栈帧构成，这些栈帧对应一个过程，而且每一个栈指针+4的位置存储函数返回地址；每一个栈帧都建立在调用者的下方，当被调用者执行完毕时，这一段栈帧会被释放。由于栈帧是向地址递减的方向延伸，因此如果我们将栈指针减去一定的值，就相当于给栈帧分配了一定空间的内存。如果将栈指针加上一定的值，也就是向上移动，那么就相当于压缩了栈帧的长度，也就是说内存被释放了。

**过程实现**

1. 备份原来的帧指针，调整当前的栈帧指针到栈指针位置；
2. 建立起来的栈帧就是为被调用者准备的，当被调用者使用栈帧时，需要给临时变量分配预留内存；
3. 使用建立好的栈帧，比如读取和写入，一般使用mov，push以及pop指令等等。
4. 恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了
5. 释放被调用者的栈帧，释放就意味着将栈指针加大，而具体的做法一般是直接将栈指针指向帧指针，因此会采用类似下面的汇编代码处理。
6. 恢复调用者的栈帧，恢复其实就是调整栈帧两端，使得当前栈帧的区域又回到了原始的位置。
7. 弹出返回地址，跳出当前过程，继续执行调用者的代码。

**过程调用和返回指令**

1. call指令
2. leave指令
3. ret指令

#### 31、说一下你理解的 ifdef endif代表着什么？

1. 一般情况下，源程序中所有的行都参加编译。但是有时希望对其中一部分内容只在满足一定条件才进行编译，也就是对一部分内容指定编译的条件，这就是“条件编译”。有时，希望当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句。
2. 在一个大的软件工程里面，可能会有多个文件同时包含一个头文件，当这些文件编译链接成一个可执行文件上时，就会出现大量“重定义”错误。**在头文件中使用#define、#ifndef、#ifdef、#endif能避免头文件重定义。**

#### 32、**隐式转换，如何消除隐式转换？**

1. C++的基本类型中并非完全的对立，部分数据类型之间是可以进行隐式转换的。**所谓隐式转换，是指不需要用户干预，编译器私下进行的类型转换行为。**很多时候用户可能都不知道进行了哪些转换
2. **C++面向对象的多态特性，就是通过父类的类型实现对子类的封装。通过隐式转换，你可以直接将一个子类的对象使用父类的类型进行返回。**在比如，数值和布尔类型的转换，整数和浮点数的转换等。某些方面来说，隐式转换给C++程序开发者带来了不小的便捷。C++是一门强类型语言，类型的检查是非常严格的。
3. **基本数据类型** 基本数据类型的转换以取值范围的作为转换基础（保证精度不丢失）。隐式转换发生在从**小->大**的转换中。比如从char转换为int。从int->long。自定义对象 子类对象可以隐式的转换为父类对象。
4. **C++中提供了explicit关键字，在构造函数声明的时候加上explicit关键字，能够禁止隐式转换。**
5. 如果构造函数只接受一个参数，则它实际上定义了转换为此类类型的隐式转换机制。可以通过将构造函数声明为explicit加以制止隐式类型转换，**关键字explicit只对一个实参的构造函数有效**，需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为explicit。

#### 33、**C++如何处理多个异常的？**

1. C++中的异常情况： 
   - **语法错误（编译错误）：比如变量未定义、括号不匹配、关键字拼写错误等等编译器在编译时能发现的错误**，这类错误可以及时被编译器发现，而且可以及时知道出错的位置及原因，方便改正。 
   - **运行时错误：比如数组下标越界、系统内存不足等等。这类错误不易被程序员发现**，它能通过编译且能进入运行，但运行时会出错，导致程序崩溃。为了有效处理程序运行时错误，C++中引入异常处理机制来解决此问题。

2. C++异常处理机制： 异常处理基本思想：执行一个函数的过程中发现异常，可以不用在本函数内立即进行处理， 而是抛出该异常，让函数的调用者直接或间接处理这个问题。 C++异常处理机制由3个模块组成：try(检查)、throw(抛出)、catch(捕获) 抛出异常的语句格式为：throw 表达式；如果try块中程序段发现了异常则抛出异常。

#### 34、**如何在不使用额外空间的情况下，交换两个数？你有几种方法**

1) 算术

```C++
x = x + y;
y = x - y;
x = x - y; 
```

2) 异或

```C++
x = x^y;// 只能对int,char..
y = x^y;
x = x^y;
x ^= y ^= x;
```

#### 35、**你知道strcpy和memcpy的区别是什么吗？**	

1. **复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容**，例如字符数组、整型、结构体、类等。 
2. **复制的方法不同。**strcpy不需要指定长度，它遇到被复制字符的串结束符"\0"才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。 
3. **用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy**

#### 36、程序在执行int main(int argc, char \*argv[])时的内存结构，你了解吗？

- 参数的含义是程序在命令行下运行的时候，需要输入argc 个参数，每个参数是以char 类型输入的，依次存在数组里面，数组是 argv[]，所有的参数在指针
- `char *` 指向的内存中，数组的中元素的个数为 argc 个，第一个参数为程序的名称。

#### 37、volatile关键字的作用？

- **volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改**，比如：操作系统、硬件或者其它线程等。**遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。**
- 声明时语法：`int volatile vInt;` 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。

**volatile用在如下的几个地方：**

1. 中断服务程序中修改的供其它程序检测的变量需要加volatile；
2. 多任务环境下各任务间共享的标志应该加volatile；
3. 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能有不同意义；

#### 38、**如果有一个空类，它会默认添加哪些函数？**

1) Empty(); // 缺省构造函数//

2) Empty( const Empty& ); // 拷贝构造函数//

3) ~Empty(); // 析构函数//

4) Empty& operator=( const Empty& ); // 赋值运算符//

#### 39、**C++中标准库是什么？**

C++ 标准库可以分为两部分：

- 标准函数库： 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。


- 面向对象类库： 这个库是类及其相关函数的集合。


- 输入/输出 I/O、字符串和字符处理、数学、时间、日期和本地化、动态分配、其他、宽字符函数


- 标准的 C++ I/O 类、String 类、数值类、STL 容器类、STL 算法、STL 函数对象、STL 迭代器、STL 分配器、本地化库、异常处理类、杂项支持库


#### 40、**你知道*****\*const\**** **char\* 与string之间的关系是什么吗？**

- **string 是c++标准库里面其中一个，封装了对字符串的操作，实际操作过程我们可以用const char\*给string类初始化**

#### 41、**你什么情况用指针当参数，什么时候用引用，为什么？**

使用引用参数的主要原因有：

- 程序员能修改调用函数中的数据对象


- 通过传递引用而不是整块数据–对象，可以提高程序的运行速度


一般的原则： 对于使用引用的值而不做修改的函数：

- 如果数据对象很小，如内置数据类型或者小型结构，则按照值传递；


- 如果数据对象是数组，则使用指针（唯一的选择），并且指针声明为指向const的指针；


- 如果数据对象是较大的结构，则使用const指针或者引用，已提高程序的效率。这样可以节省结构所需的时间和空间；


- **如果数据对象是类对象，则使用const引用（传递类对象参数的标准方式是按照引用传递）；**

对于修改函数中数据的函数：

- 如果数据是内置数据类型，则使用指针


- 如果数据对象是结构，则使用引用或者指针


- 如果数据是类对象，则使用引用


#### 42、**在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处有哪些？**

对比值传递，引用传参的好处：

1. **在函数内部可以对此参数进行修改**
2. **提高函数调用和运行的效率**（因为没有了传值和生成副本的时间和空间消耗）

如果函数的参数实质就是形参，不过这个形参的作用域只是在函数体内部，也就是说实参和形参是两个不同的东西，要想形参代替实参，肯定有一个值的传递。函数调用时，值的传递机制是通过“形参=实参”来对形参赋值达到传值目的，产生了一个实参的副本。即使函数内部有对参数的修改，也只是针对形参，也就是那个副本，实参不会有任何更改。函数一旦结束，形参生命也宣告终结，做出的修改一样没对任何变量产生影响。

用引用作为返回值最大的好处就是在内存中不产生被返回值的副本。**但是有以下的限制：**

1. **不能返回局部变量的引用。**因为函数返回以后局部变量就会被销毁
2. **不能返回函数内部new分配的内存的引用。**虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak
3. **可以返回类成员的引用，但是最好是const。**因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。

#### 43、怎么快速定位错误出现的地方?

1. 如果是简单的错误，可以直接双击错误列表里的错误项或者生成输出的错误信息中带行号的地方就可以让编辑窗口定位到错误的位置上。
2. 对于复杂的模板错误，最好使用生成输出窗口。
3. 多数情况下触发错误的位置是最靠后的引用位置。如果这样确定不了错误，就需要先把自己写的代码里的引用位置找出来，然后逐个分析了。

#### 44、**如何设计一个计算仅单个子类的对象个数？**

1. 为类设计一个static静态变量count作为计数器；
2. 类定义结束后初始化count;
3. 在构造函数中对count进行+1;
4. 设计拷贝构造函数，在进行拷贝构造函数中进行count +1，操作；
5. 设计复制构造函数，在进行复制函数中对count+1操作；
6. 在析构函数中对count进行-1；

#### 45、**成员初始化列表会在什么时候用到？它的调用过程是什么？**

1. 当初始化一个引用成员变量时；
2. 初始化一个const成员变量时；
3. 当调用一个基类的构造函数，而构造函数拥有一组参数时；
4. 当调用一个成员类的构造函数，而他拥有一组参数；
5. 编译器会一一操作初始化列表，以适当顺序在构造函数之内安插初始化操作，并且在任何显示用户代码前。list中的项目顺序是由类中的成员声明顺序决定的，不是初始化列表中的排列顺序决定的。

#### 46、你知道回调函数吗？它的作用？

1. **当发生某种事件时，系统或其他函数将会自动调用你定义的一段函数**；
2. **回调函数就相当于一个中断处理函数，由系统在符合你设定的条件时自动调用。**为此，你需要做三件事：**1，声明；2，定义；3，设置触发条件，就是在你的函数中把你的回调函数名称转化为地址作为一个参数，以便于系统调用；**
3. **回调函数就是一个通过函数指针调用的函数。**如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数；
4. 因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为int）的被调用函数。

#### 47、**成员函数里memset(this,0,sizeof(\*this))会发生什么**

- 有时候类里面定义了很多int,char,struct等c语言里的那些类型的变量，我习惯在构造函数中将它们初始化为0，但是一句句的写太麻烦，所以直接就memset(this, 0, sizeof *this);将整个对象的内存全部置为0。对于这种情形可以很好的工作，但是下面几种情形是不可以这么使用的；
  - 类含有虚函数表：这么做会破坏虚函数表，后续对虚函数的调用都将出现异常；
  - 类中含有C++类型的对象：例如，类中定义了一个list的对象，由于在构造函数体的代码执行之前就对list对象完成了初始化，假设list在它的构造函数里分配了内存，那么我们这么一做就破坏了list对象的内存。

#### 48、**说一说strcpy、sprintf与memcpy这三个函数的不同之处**

**操作对象不同**

1. strcpy的两个操作对象均为字符串
2. sprintf的操作源对象可以是多种数据类型，目的操作对象是字符串
3. memcpy的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。

**执行效率不同**

1. memcpy最高，strcpy次之，sprintf的效率最低。


**实现功能不同**

1. strcpy主要实现字符串变量间的拷贝
2. sprintf主要实现其他数据类型格式到字符串的转化
3. memcpy主要是内存块间的拷贝。

#### 49、**将引用作为函数参数有哪些好处？**

1. 传递引用给函数与传递指针的效果是一样的。

   - 这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。
2. **使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；**
   - 而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；
   - 如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。
3. 使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用"*指针变量名"的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。

#### 50、**你知道Debug和Release的区别是什么吗？**

1. 调试版本，包含调试信息，所以容量比Release大很多，并且不进行任何优化（优化会使调试复杂化，因为源代码和生成的指令间关系会更复杂），便于程序员调试。Debug模式下生成两个文件，除了.exe或.dll文件外，还有一个.pdb文件，该文件记录了代码中断点等调试信息；
2. 发布版本，不对源代码进行调试，编译时对应用程序的速度进行优化，使得程序在代码大小和运行速度上都是最优的。（调试信息可在单独的PDB文件中生成）。Release模式下生成一个文件.exe或.dll文件。
3. 实际上，Debug 和 Release 并没有本质的界限，他们只是一组编译选项的集合，编译器只是按照预定的选项行动。事实上，我们甚至可以修改这些选项，从而得到优化过的调试版本或是带跟踪语句的发布版本。

#### 51、**strcpy**函数和strncpy函数的区别？哪个函数更安全？

`char* strcpy(char* strDest, const char* strSrc)`

`char *strncpy(char *dest, const char *src, size_t n)`

- strcpy函数: 如果参数 dest 所指的内存空间不够大，可能会造成缓冲溢出(buffer Overflow)的错误情况，在编写程序时请特别留意，或者用strncpy()来取代。


- strncpy函数：用来复制源字符串的前n个字符，src 和 dest 所指的内存区域不能重叠，且 dest 必须有足够的空间放置n个字符。 

  - 如果目标长>指定长>源长，则将源长全部拷贝到目标长，自动加上’\0’
  - 如果指定长<源长，则将源长中按指定长度拷贝到目标字符串，不包括’\0’
  - 如果指定长>目标长，运行时错误

#### 52、**模板会写吗？写一个比较大小的模板函数**

```C++
#include<iostream> 

using namespace std; 
template<typename type1,typename type2>//函数模板 

type1 Max(type1 a,type2 b) 
{ 
   return a > b ? a : b; 
} 

void main() 
 { 
  cout<<"Max = "<<Max(5.5,'a')<<endl; 
} 
```

其实该模板有个比较隐晦的bug，那就是a、b只有在能进行转型的时候才能进行比较，否则 a > b 这一步是会报错的。

这个时候往往需要对于 > 号进行重载，这代码量瞬间上来了。

#### 55、**用C语言实现C++的继承**

#### 56、**什么是一致性哈希？**

一致性哈希

一致性哈希是一种哈希算法，就是在移除或者增加一个结点时，能够尽可能小的改变已存在key的映射关系

尽可能少的改变已有的映射关系，一般是沿着顺时针进行操作，回答之前可以先想想，真实情况如何处理

一致性哈希将整个哈希值空间组织成一个虚拟的圆环，假设哈希函数的值空间为0~2^32-1，整个哈希空间环如下左图所示

![img](file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml12484\wps1.jpg) 

一致性hash的基本思想就是使用相同的hash算法将数据和结点都映射到图中的环形哈希空间中，上右图显示了4个数据object1-object4在环上的分布图

结点和数据映射

假如有一批服务器，可以根据IP或者主机名作为关键字进行哈希，根据结果映射到哈希环中，3台服务器分别是nodeA-nodeC

现在有一批的数据object1-object4需要存在服务器上，则可以使用相同的哈希算法对数据进行哈希，其结果必然也在环上，可以沿着顺时针方向寻找，找到一个结点（服务器）则将数据存在这个结点上，这样数据和结点就产生了一对一的关联，如下图所示：

 

![img](file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml12484\wps2.jpg) 

移除结点

如果一台服务器出现问题，如上图中的nodeB，则受影响的是其逆时针方向至下一个结点之间的数据，只需将这些数据映射到它顺时针方向的第一个结点上即可，下左图

![img](file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml12484\wps3.jpg) 

添加结点

如果新增一台服务器nodeD，受影响的是其逆时针方向至下一个结点之间的数据，将这些数据映射到nodeD上即可，见上右图

虚拟结点

假设仅有2台服务器：nodeA和nodeC，nodeA映射了1条数据，nodeC映射了3条，这样数据分布是不平衡的。引入虚拟结点，假设结点复制个数为2，则nodeA变成：nodeA1和nodeA2，nodeC变成：nodeC1和nodeC2，映射情况变成如下：

![img](file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml12484\wps4.jpg) 

这样数据分布就均衡多了，平衡性有了很大的提高

#### 40、**你知道*****\*const\**** **char\* 与string之间的关系是什么吗？**

**①** ***\*string 是c++标准库里面其中一个，封装了对字符串的操作，实际操作过程我们可以用const char\*给string类初始化\****

② 三者的转化关系如下所示：

a)  string转const char* 

 

string s = “abc”; 

 

const char* c_s = s.c_str(); 

 

b)  const char* 转string，直接赋值即可 

 

const char* c_s = “abc”; 

 string s(c_s); 

 

c)  string 转char* 

 string s = “abc”; 

 char* c; 

 const int len = s.length(); 

 c = new char[len+1]; 

 strcpy(c,s.c_str()); 

 

d)  char* 转string 

 char* c = “abc”; 

 string s(c); 

 

e)  const char* 转char* 

 const char* cpc = “abc”; 

 char* pc = new char[strlen(cpc)+1]; 

 strcpy(pc,cpc);

 

f)  char* 转const char*，直接赋值即可 

 char* pc = “abc”; 

 const char* cpc = pc;

#### 21、**结构体变量比较是否相等**

重载了 “==” 操作符

```C++
struct foo {

 int a;

 int b;

 bool operator==(const foo& rhs) *//* *操作运算符重载*

 {

  return( a == rhs.a) && (b == rhs.b);

 }

};
```

元素的话，一个个比；

指针直接比较，如果保存的是同一个实例地址，则(p1==p2)为真；
