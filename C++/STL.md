#### 1、**请说说 STL 的基本组成部分**

- 标准模板库（Standard Template Library,简称STL）简单说，就是一些常用数据结构和算法的模板的集合。广义上讲，STL分为3类：<u>Algorithm（算法）、Container（容器）和Iterator（迭代器）</u>，容器和算法通过迭代器可以进行无缝地连接。详细的说，STL由6部分组成：容器(Container)、算法（Algorithm）、 迭代器（Iterator）、仿函数（Function object）、适配器（Adaptor）、空间配制器（Allocator）。

**标准模板库STL主要由6大组成部分：**

**容器(Container)**

- 是一种数据结构， 如list, vector, 和deques，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器。


**算法（Algorithm）**

- 是用来操作容器中的数据的模板函数。


**迭代器（Iterator）**

- 提供了访问容器中对象的方法。


**仿函数（Function object）**

- 仿函数又称之为函数对象， 其实就是重载了操作符的struct,没有什么特别的地方。


**适配器（Adaptor）**

- 简单的说就是一种接口类，专门用来修改现有类的接口，提供一中新的接口；或调用现有的函数来实现所需要的功能。主要包括3中适配器Container Adaptor、Iterator Adaptor、Function Adaptor。


**空间配制器（Allocator）**

1. 为STL提供空间配置的系统。其中主要工作包括两部分：
   1. 对象的创建与销毁；
   2. 内存的获取与释放。

#### 2、**请说说 STL 中常见的容器，并介绍一下实现原理**

容器可以用于存放各种类型的数据（基本类型的变量，对象等）的数据结构，都是模板类，分为顺序容器、关联式容器、容器适配器三种类型，三种类型容器特性分别如下：

① 顺序容器

容器并非排序的，元素的插入位置同元素的值无关。包含vector、deque、list，具体实现原理如下：

（1）vector 头文件

动态数组。元素在内存连续存放。随机存取任何元素都能在常数时间完成。在尾端增删元素具有较佳的性能。

（2）deque 头文件

双向队列。元素在内存连续存放。随机存取任何元素都能在常数时间完成（仅次于vector）。在两端增删元素具有较佳的性能（大部分情况下是常数时间）。

（3）list 头文件

双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。

② 关联式容器

元素是排序的；插入任何元素，都按相应的排序规则来确定其位置；在查找时具有非常好的性能；通常以平衡二叉树的方式实现。包含set、multiset、map、multimap，具体实现原理如下：

（1）set/multiset 头文件

set 即集合。set中不允许相同元素，multiset中允许存在相同元素。

（2）map/multimap 头文件

map与set的不同在于map中存放的元素有且仅有两个成员变量，一个名为first,另一个名为second, map根据first值对元素从小到大排序，并可快速地根据first来检索元素。

**注意：map和multimap的不同在于是否允许相同first值的元素。**

③ 容器适配器

封装了一些基本的容器，使之具备了新的函数功能，比如把deque封装一下变为一个具有stack功能的数据结构。这新得到的数据结构就叫适配器。包含stack,queue,priority_queue，具体实现原理如下：

（1）stack 头文件

栈是项的有限序列，并满足序列中被删除、检索和修改的项只能是最进插入序列的项（栈顶的项）。后进先出。

（2）queue 头文件

队列。插入只可以在尾部进行，删除、检索和修改只允许从头部进行。先进先出。

（3）priority_queue 头文件

优先级队列。内部维持某种有序，然后确保优先级最高的元素总是位于头部。最高优先级元素总是第一个出列。

#### 3、**常见容器性质总结？**

1. vector 底层数据结构为数组 ，支持快速随机访问
2. list 底层数据结构为双向链表，支持快速增删
3. deque 底层数据结构为一个中央控制器和多个缓冲区，详细见STL源码剖析P146，支持首尾（中间不能）快速增删，也支持随机访问deque是一个双端队列(double-ended queue)，也是在堆中保存内容的.它的保存形式如下:[堆1] --> [堆2] -->[堆3] --> ...每个堆保存好几个元素,然后堆和堆之间有指针指向,看起来像是list和vector的结合品.
4. stack 底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时
5. queue 底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时（stack和queue其实是适配器,而不叫容器，因为是对容器的再封装）
6. priority_queue 的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现
7. set 底层数据结构为红黑树，有序，不重复
8. multiset 底层数据结构为红黑树，有序，可重复
9. map 底层数据结构为红黑树，有序，不重复
10. multimap 底层数据结构为红黑树，有序，可重复
11. unordered_set 底层数据结构为hash表，无序，不重复
12. unordered_multiset 底层数据结构为hash表，无序，可重复
13. unordered_map 底层数据结构为hash表，无序，不重复
14. unordered_multimap 底层数据结构为hash表，无序，可重复

#### 4、STL 容器用过哪些，查找的时间复杂度是多少，为什么

STL中常用的容器有vector、deque、list、map、set、multimap、multiset、unordered_map、unordered_set等。容器底层实现方式及时间复杂度分别如下：

1. vector：采用一维数组实现，元素在内存连续存放，不同操作的时间复杂度为：

- 插入: O(N)
- 查看: O(1)
- 删除: O(N)

2. deque：采用双向队列实现，元素在内存连续存放，不同操作的时间复杂度为：

- 插入: O(N)
- 查看: O(1)删除: O(N)

3. list：采用双向链表实现，元素存放在堆中，不同操作的时间复杂度为：

- 插入: O(1)
- 查看: O(N)
- 删除: O(1)

4. map、set、multimap、multiset：这四种容器采用红黑树实现，红黑树是平衡二叉树的一种。不同操作的时间复杂度近似为:

- 插入: O(logN)
- 查看: O(logN)
- 删除: O(logN)

#### 5、**说一下STL每种容器对应的迭代器**

- 随机访问迭代器：vector、deque
- 双向迭代器：list、(multi)set/map
- 前向迭代器：unordered_(multi)set/map、forward_list 

#### 6、**STL中vector的实现**

- vector是一种序列式容器，其数据安排以及操作方式与array非常类似，两者的唯一差别就是对于空间运用的灵活性，众所周知，array占用的是静态空间，一旦配置了就不可以改变大小，如果遇到空间不足的情况还要自行创建更大的空间，并手动将数据拷贝到新的空间中，再把原来的空间释放。vector则使用灵活的动态空间配置，维护一块连续的线性空间，在空间不足时，可以自动扩展空间容纳新元素，做到按需供给。其在扩充空间的过程中仍然需要经历：重新配置空间，移动数据，释放原空间等操作。这里需要说明一下动态扩容的规则：以原大小的两倍配置另外一块较大的空间（或者旧长度+新增元素的个数）vector扩容倍数与平台有关，在Win + VS 下是 1.5倍，在 Linux + GCC 下是 2 倍需要注意的是，频繁对vector调用push_back()对性能是有影响的，这是因为每插入一个元素，如果空间够用的话还能直接插入，若空间不够用，则需要重新配置空间，移动数据，释放原空间等操作，对程序性能会造成一定的影响。


#### 7、**简述 vector 的实现原理**

vector底层实现原理为一维数组（元素在空间连续存放）。

1. 新增元素
   - vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素。插入新的数据分在最后插入push_back和通过迭代器在任何位置插入，这里说一下通过迭代器插入，通过迭代器与第一个元素的距离知道要插入的位置，即int index=iter-begin()。这个元素后面的所有元素都向后移动一个位置，在空出来的位置上存入新增的元素。

2. 删除元素
   - 删除和新增差不多，也分两种，删除最后一个元素pop_back和通过迭代器删除任意一个元素erase(iter)。通过迭代器删除还是先找到要删除元素的位置，即int index=iter-begin();这个位置后面的每个元素都想前移动一个元素的位置。同时我们知道erase不释放内存只初始化成默认值。删除全部元素clear：只是循环调用了erase，所以删除全部元素的时候，不释放内存。内存是在析构函数中释放的。

3. 迭代器iteraotr
   - 迭代器iteraotr是STL的一个重要组成部分,通过iterator可以很方便的存储集合中的元素.STL为每个集合都写了一个迭代器, 迭代器其实是对一个指针的包装,实现一些常用的方法,如++,--,!=,==,*,->等,通过这些方法可以找到当前元素或是别的元素. vector是STL集合中比较特殊的一个,因为vector中的每个元素都是连续的,所以在自己实现vector的时候可以用指针代替。

#### 8、**STL 中vector删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？**

- size()函数返回的是已用空间大小，capacity()返回的是总空间大小，capacity()-size()则是剩余的可用空间大小。当size()和capacity()相等，说明vector目前的空间已被用完，如果再添加新元素，则会引起vector空间的动态增长。

- 由于动态增长会引起重新分配内存空间、拷贝原空间、释放原空间，这些过程会降低程序效率。因此，可以使用reserve(n)预先分配一块较大的指定大小的内存空间，这样当指定大小的内存空间未使用完时，是不会重新分配内存空间的，这样便提升了效率。只有当n>capacity()时，调用reserve(n)才会改变vector容量。

- resize()成员函数改变元素的数目，至于空间的的变化需要看具体情况去分析，如下：
  1. 空的vector对象，size()和capacity()都为0
  2. 当空间大小不足时，新分配的空间大小为原空间大小的2倍。
  3. 使用reserve()预先分配一块内存后，在空间未满的情况下，不会引起重新分配，从而提升了效率。
  4. 当reserve()分配的空间比原空间小时，是不会引起重新分配的。
  5. resize()函数只改变容器的元素数目，未改变容器大小。
  6. 用reserve(size_type)只是扩大capacity值，这些内存空间可能还是“野”的，如果此时使用“[ ]”来访问，则可能会越界。而resize(size_type new_size)会真正使容器具有new_size个对象。
- 不同的编译器，vector有不同的扩容大小。在vs下是1.5倍，在GCC下是2倍；
- 空间和时间的权衡。简单来说， 空间分配的多，平摊时间复杂度低，但浪费空间也多。
- 使用k=2增长因子的问题在于，每次扩展的新尺寸必然刚好大于之前分配的总和，也就是说，之前分配的内存空间不可能被使用。这样对内存不友好，最好把增长因子设为(1, 2)，也就是1-2之间的某个数值。对比可以发现***\*采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此，使用成倍的方式扩容。\****

#### 9、**vector如何释放空间?**

- 由于vector的内存占用空间只增不减，比如你首先分配了10,000个字节，然后erase掉后面9,999个，留下一个有效元素，但是内存占用仍为10,000个。所有内存空间是在vector析构时候才能被系统回收。empty()用来检测容器是否为空的，clear()可以清空所有元素。但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收。

- 如果需要空间动态缩小，可以考虑使用deque。如果vector，可以用swap()来帮助你释放内存。

#### 10、vector的增加删除都是怎么做的？

① 新增元素：vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素；

② 对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了 ；

③ 初始时刻vector的capacity为0，塞入第一个元素后capacity增加为1；

④ 不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容。

对比可以发现采用采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此，使用成倍的方式扩容

#### 11、**STL中list的实现**

- 相比于vector的连续线型空间，list显得复杂许多，但是它的好处在于插入或删除都只作用于一个元素空间，因此list对空间的运用是十分精准的，对任何位置元素的插入和删除都是常数时间。list不能保证节点在存储空间中连续存储，也拥有迭代器，迭代器的“++”、“--”操作对于的是指针的操作，list提供的迭代器类型是双向迭代器：Bidirectional iterators。
- list是一个双向链表。list与vector的另一个区别是，在插入和接合操作之后，都不会造成原迭代器失效，而vector可能因为空间重新配置导致迭代器失效。
- list也是一个环形链表，因此只要一个指针便能完整表现整个链表。list中node节点指针始终指向尾端的一个空白节点，因此是一种“前闭后开”的区间结构
- list的空间管理默认采用alloc作为空间配置器，**为了方便的以节点大小为配置单位，还定义一个list_node_allocator函数可一次性配置多个节点空间。**

#### 11、**STL中list的实现**

- 相比于vector的连续线型空间，list显得复杂许多，但是它的好处在于插入或删除都只作用于一个元素空间，因此list对空间的运用是十分精准的，对任何位置元素的插入和删除都是常数时间。list不能保证节点在存储空间中连续存储，也拥有迭代器，迭代器的“++”、“--”操作对于的是指针的操作，list提供的迭代器类型是双向迭代器：Bidirectional iterators。

list节点的结构见如下源码：

template <class T>

struct __list_node{

  typedef void* void_pointer;

  void_pointer prev;

  void_pointer next;

  T data;

}

从源码可看出list显然是一个双向链表。list与vector的另一个区别是，在插入和接合操作之后，都不会造成原迭代器失效，而vector可能因为空间重新配置导致迭代器

#### 12、**STL中迭代器失效的情况有哪些？**

**vector：**

- **插入元素：**
  - 1、尾后插入：size < capacity时，首迭代器不失效尾迭代失效（未重新分配空间），size == capacity时，所有迭代器均失效（需要重新分配空间）。
  - 2、中间插入：中间插入：size < capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size == capacity时，所有迭代器均失效。

- 删除元素：
  - 尾后删除：只有尾迭代失效。
  - 中间删除：删除位置之后所有迭代失效。

**deque 和 vector 的情况类似**

而 list 双向链表每一个节点内存不连续, 删除节点仅当前迭代器失效,erase返回下一个有效迭代器;

map/se t等关联容器底层是红黑树删除节点不会影响其他节点的迭代器, 使用递增方法获取下一个迭代器 mmp.erase(iter++);

unordered_(hash)  迭代器意义不大, rehash 之后, 迭代器应该也是全部失效.

#### 13、**说说 vector** 和 list 的区别，分别适用于什么场景？

<u>vector和list区别在于底层实现机理不同，因而特性和适用场景也有所不同。</u> 

**vector：一维数组**

- 特点：元素在内存连续存放，动态数组，在堆中分配内存，元素连续存放，有保留内存，如果减少大小后内存也不会释放。 
- 优点：和数组类似开辟一段连续的空间，并且支持随机访问，所以它的查找效率高其时间复杂度 O(1)。 
- 缺点：由于开辟一段连续的空间，所以插入删除会需要对数据进行移动比较麻烦，时间复杂度 O（n），另外当空间不足时还需要进行扩容。 

**list：双向链表** 

- 特点：元素在堆中存放，每个元素都是存放在一块内存中，它的内存空间可以是不连续的，通过指针来进行数据的访问。 
- 优点：底层实现是循环双链表，当对大量数据进行插入删除时，其时间复杂度O(1)。 
- 缺点：底层没有连续的空间，只能通过指针来访问，所以查找数据需要遍历其时间复杂度O（n）， 没有提供[]操作符的重载。

**应用场景** 

- vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随机访问，而不在乎插入和删除的效率，使用vector。 
- list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。

#### 14、**C++ 的 vector 和 list中，如果删除末尾的元素，其指针和迭代器如何变化？若删除的是中间的元素呢？**

1. 迭代器和指针之间的区别
   - 迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，重载了指针的一些操作符，-->、++、--等。迭代器封装了指针，是一个”可遍历STL（ Standard TemplateLibrary）容器内全部或部分元素”的对象，本质是封装了原生指针，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，--等操作。
   - 迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用取值后的值而不能直接输出其自身。

2. vector和list特性
   - vector特性 动态数组。元素在内存连续存放。随机存取任何元素都在常数时间完成。在尾端增删元素具有较大的性能（大部分情况下是常数时间）。
   - list特性 双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。

3. vector增删元素
   - 对于vector而言，删除某个元素以后，该元素后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器。

4. list增删元素
   - 对于list而言，删除某个元素，只有“指向被删除元素”的那个迭代器失效，其它迭代器不受任何影响。

#### 15、**STL** **中** **vector** **与 list 具体是怎么实现的？常见操作的时间复杂度是多少？**

1. vector （元素在内存连续存放）
   - vector是动态数组，在堆中分配内存，元素连续存放，有保留内存，如果减少大小后，内存也不会释放；如果新增大小当前大小时才会重新分配内存。


2. list 双向链表（元素存放在堆中）
   - 元素存放在堆中，每个元素都是放在一块内存中，它的内存空间可以是不连续的，通过指针来进行数据的访问，这个特点，使得它的**随机存取变得非常没有效率\****，因此它没有提供[ ]操作符的重载。但是由于链表的特点，**它可以很有效的支持任意地方的删除和插入操作。**
   - *特点：**a. 随机访问不方便 b. 删除插入操作方便

3. 常见时间复杂度
   - vector插入、查找、删除时间复杂度分别为：O(n)、O(1)、O(n)； 
   - list插入、查找、删除时间复杂度分别为：O(1)、O(n)O(1)。

#### 16、**简述 STL 中的 map 的实现原理**

- map是关联式容器，map 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。不允许键值重复。
-  map内部实现了一个红黑树（红黑树是非严格平衡的二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树有自动排序的功能，因此map内部所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉树（又名二叉查找树、二叉排序树）存储的，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使用中序遍历可将键值按照从小到大遍历出来。map的特性是所有元素会根据键值进行自动排序。map中所有的元素都是pair，拥有键值(key)和实值(value)两个部分，并且不允许元素有相同的key。
- <u>一旦map的key确定了，那么是无法修改的，但是可以修改这个key对应的value</u>。
- map的在构造时缺省采用递增排序key，也使用alloc配置器配置空间大小，需要注意的是在插入元素时，调用的是红黑树中的insert_unique()方法，而非insert_euqal()（multimap使用）

- **map的特性如下**
  1. map以RBTree作为底层容器；
  2. 所有元素都是键+值存在；
  3. 不允许键重复所有元素是通过键进行自动排序的；
  4. map的键是不能修改的，但是其键对应的值是可以修改的。
- **红黑树的特性：**
  - 每个节点不是红色就是黑色
  - 根结点为黑色
  - 如果节点为红色，其子节点必为黑
  - **任一节点至（NULL）树尾端的任何路径，所含的黑节点数量必相同**

#### 17、**STL中set的实现？**

- STL中的容器可分为序列式容器（sequence）和关联式容器（associative），set属于关联式容器。
- set的特性是，所有元素都会根据元素的值自动被排序（默认升序），set元素的键值就是实值，实值就是键值，set不允许有两个相同的键值。
- set不允许迭代器修改元素的值，其迭代器是一种constance iterators。
- 标准的STL set以RB-tree（红黑树）作为底层机制，几乎所有的set操作行为都是转调用RB-tree的操作行为。

#### 18、**请你来说一下 map 和 set 有什么区别，分别又是怎么实现的？**

1. set是一种关联式容器，其特性如下：
   - set以RBTree作为底层容器
   - 所得元素的只有key没有value，value就是key 
   - 不允许出现键值重复
   - 所有的元素都会被自动排序
   - 不能通过迭代器来改变set的值，因为set的值就是键，set的迭代器是const的 
2. map和set一样是关联式容器，其特性如下：
   1. map以RBTree作为底层容器
   2. 所有元素都是键+值存在
   3. 不允许键重复
   4. 所有元素是通过键进行自动排序的
   5. map的键是不能修改的，但是其键对应的值是可以修改的

#### 19、**STL中的deque的实现**

- vector是单向开口（尾部）的连续线性空间，deque则是一种双向开口的连续线性空间，虽然vector也可以在头尾进行元素操作，但是其头部操作的效率十分低下（主要是涉及到整体的移动）

![img](https://img2020.cnblogs.com/blog/1657559/202107/1657559-20210728211357818-746549817.png)

- deque和vector的最大差异一个是deque运行在常数时间内对头端进行元素操作，二是deque没有容量的概念，它是动态地以分段连续空间组合而成，可以随时增加一段新的空间并链接起来。
- deque虽然也提供随机访问的迭代器，但是其迭代器并不是普通的指针，其复杂程度比vector高很多，因此除非必要，否则一般使用vector而非deque。如果需要对deque排序，可以先将deque中的元素复制到vector中，利用sort对vector排序，再将结果复制回deque
- deque由一段一段的定量连续空间组成，一旦需要增加新的空间，只要配置一段定量连续空间拼接在头部或尾部即可，因此deque的最大任务是如何维护这个整体的连续性
-  deque的数据结构如下：

![img](https://img2020.cnblogs.com/blog/1657559/202107/1657559-20210728212220991-1931832786.png)

- 从deque的迭代器数据结构可以看出，为了保持与容器联结，迭代器主要包含上述4个元素
- deque迭代器的“++”、“--”操作是远比vector迭代器繁琐，其主要工作在于缓冲区边界，如何从当前缓冲 区跳到另一个缓冲区，当然deque内部在插入元素时，如果map中node数量全部使用完，且node指向的缓 冲区也没有多余的空间，这时会配置新的map（2倍于当前+2的数量）来容纳更多的node，也就是可以指 向更多的缓冲区。在deque删除元素时，也提供了元素的析构和空闲缓冲区空间的释放等机制。

#### 20、**STL中**hashtable的实现？

- STL中的hashtable，使用vector作为底层容器来构建一个bucket(桶)的聚合体，每一个桶维护一个链表来存储元素。能够设计一个哈希函数，使得每一个元素的关键字与一个值一一对应。
- hashtable中的bucket所维护的list既不是list也不是slist，而是其自己定义的由hashtable_node数据结构组成的linked-list，而bucket聚合体本身使用vector进行存储。hashtable的迭代器只提供前进操作，不提供后退操作
- 在hashtable设计bucket的数量上，其内置了28个质数[53, 97, 193,...,429496729]，在创建hashtable时，会根据存入的元素个数选择大于等于元素个数的质数作为hashtable的容量（vector的长度），其中每个bucket所维护的linked-list长度也等于hashtable的容量。如果插入hashtable的元素个数超过了bucket的容量，就要进行重建table操作，即找出下一个质数，创建新的buckets vector，重新计算元素在新hashtable的位置。

#### 21、**STL中stack和queue的实现**

**stack**

- stack（栈）是一种先进后出（First In Last Out）的数据结构，只有一个入口和出口，那就是栈顶，除了获取栈顶元素外，没有其他方法可以获取到内部的其他元素，其结构图如下：


![img](file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml8644\wps8.jpg) 

- stack这种单向开口的数据结构很容易由双向开口的deque和list形成，只需要根据stack的性质对应移除某些接口即可实现。


- stack除了默认使用deque作为其底层容器之外，也可以使用双向开口的list，只需要在初始化stack时，将list作为第二个参数即可。由于stack只能操作顶端的元素，因此其内部元素无法被访问，也不提供迭代器。


**queue**

- queue（队列）是一种先进先出（First In First Out）的数据结构，只有一个入口和一个出口，分别位于最底端和最顶端，出口元素外，没有其他方法可以获取到内部的其他元素，其结构图如下：


![img](file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml8644\wps9.jpg) 

- 类似的，queue这种“先进先出”的数据结构很容易由双向开口的deque和list形成，只需要根据queue的性质对应移除某些接口即可实现，同样，queue也可以使用list作为底层容器，不具有遍历功能，没有迭代器。


#### 22、**说说 STL** **中 map** **hashtable deque list 的实现原理**

map、hashtable、deque、list实现机理分别为红黑树、函数映射、双向队列、双向链表，他们的特性分别如下：

1. **map实现原理**
   - map内部实现了一个红黑树（红黑树是非严格平衡的二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树有自动排序的功能，因此map内部所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉树（又名二叉查找树、二叉排序树）存储的，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使用中序遍历可将键值按照从小到大遍历出来。


2. **hashtable（也称散列表，直译作哈希表）实现原理**
   - hashtable采用了函数映射的思想记录的存储位置与记录的关键字关联起来，从而能够很快速地进行查找。这决定了哈希表特殊的数据结构，它同数组、链表以及二叉排序树等相比较有很明显的区别，它能够快速定位到想要查找的记录，而不是与表中存在的记录的关键字进行比较来进行查找。


3. **deque实现原理**
   - deque内部实现的是一个双向队列。元素在内存连续存放。随机存取任何元素都在常数时间完成（仅次于vector）。所有适用于vector的操作都适用于deque。在两端增删元素具有较佳的性能（大部分情况下是常数时间）。


4. **list实现原理**
   - list内部实现的是一个双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。无成员函数，给定一个下标i，访问第i个元素的内容，只能从头部挨个遍历到第i个元素。


#### 23、**STL中的priority_queue的实现**

- priority_queue，优先队列，是一个拥有权值观念的queue，它跟queue一样是顶部入口，底部出口，在插入元素时，元素并非按照插入次序排列，它会自动根据权值（通常是元素的实值）排列，权值最高，排在最前面，如下图所示。


​	![img](file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml8644\wps10.jpg) 

- 默认情况下，priority_queue使用一个max-heap完成，底层容器使用的是一般为vector为底层容器，堆heap为处理规则来管理底层容器实现 。priority_queue的这种实现机制导致其不被归为容器，而是一种容器配接器。
- priority_queue的所有元素，进出都有一定的规则，只有queue顶端的元素（权值最高者），才有机会被外界取用，它没有遍历功能，也不提供迭代器

#### 24、**map**插入方式？

① 用insert函数插入pair数据

`mapStudent.insert(pair<int, string>(1, "student_one"));` 

② 用insert函数插入value_type数据

`mapStudent.insert(map<int, string>::value_type (1, "student_one"));`

③ 在insert函数中使用make_pair()函数

`mapStudent.insert(make_pair(1, "student_one"));` 

④ 用数组方式插入数据

`mapStudent[1] = "student_one";` 

#### 25、**STL中**unordered**_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容 **

1. unordered_map和map类似，都是存储的key-value的值，可以通过key快速索引到value。不同的是unordered_map不会根据key的大小进行排序。
2. 存储时是根据key的hash值判断元素是否相同，即unordered_map内部元素是无序的，而map中的元素是按照二叉搜索树存储，进行中序遍历会得到有序遍历。
3. 所以使用时map的key需要定义operator<。而unordered_map需要定义hash_value函数并且重载operator==。但是很多系统内置的数据类型都自带这些。
4. 那么如果是自定义类型，那么就需要自己重载operator<或者hash_value()了。
5. 如果需要内部元素自动排序，使用map，不需要排序使用unordered_map
6. unordered_map的底层实现是hash_table;
7. hash_map底层使用的是hash_table，而hash_table使用的开链法进行冲突避免，所有hash_map采用开链法进行冲突解决。
8. **什么时候扩容：**当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值---即当前数组的长度乘以加载因子的值的时候，就要自动扩容。
9. **扩容(resize)**就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。

#### 26、**STL中unordered_map和map的区别和应用场景**

- map支持键值的自动排序，底层机制是红黑树，红黑树的查询和维护时间复杂度均为O(log(n))，但是空间占用比较大，因为每个节点要保持父节点、孩子节点及颜色的信息。
- Unordered_map是C++11新添加的容器，底层机制是哈希表，通过hash函数计算元素位置，其查询时间复杂度O(1)，维护时间和bucket桶所维护的list长度有关，但是建立hash表耗时大。
- 从两者底层实现来看，map适用于有序数据的应用场景，unordered_map适用于高效查询的应用场。

#### 27、说说 map 和 unordered_map 的区别？底层实现

- map和unordered_map的区别在于他们的实现基理不同。 


1. map实现机理
   - map内部实现了一个红黑树（红黑树是非严格平衡的二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树有自动排序的功能，因此map内部所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉树（又名二叉查找树、二叉排序树）存储的，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使用中序遍历可将键值按照从小到大遍历出来。


2. unordered_map实现机理
   - unordered_map内部实现了一个哈希表（也叫散列表），通过把关键码值映射到Hash表中一个位置来访问记录，查找时间复杂度可达O（1），其中在海量数据处理中有着广泛应用。因此，元素的排列顺序是无序的。


#### 28、**vector越界**访问**下标，map越界访问下标？vector删除元素时会不会释放空间？**

- ① 通过下标访问vector中的元素时会做边界检查，但该处的实现方式要看具体IDE，不同IDE的实现方式不一样，确保不可访问越界地址。
- ② map的下标运算符[]的作用是：将key作为下标去执行查找，并返回相应的值；如果不存在这个key，就将一个具有该key和value的某值插入这个map。

- ③ erase()函数，只能删除内容，不能改变容量大小;
- ④ erase成员函数，它删除了itVect迭代器指向的元素，并且返回要被删除的itVect之后的迭代器，迭代器相当于一个智能指针;
- ⑤ clear()函数，只能清空内容，不能改变容量大小;如果要想在删除内容的同时释放内存，那么你可以选择deque容器。

#### 29、**map中[]与find的区别？**

- map的下标运算符[]的作用是：将关键码作为下标去执行查找，并返回对应的值；如果不存在这个关键码，就将一个具有该关键码和值类型的默认值的项插入这个map。
- map的find函数：用关键码执行查找，找到了返回该位置的迭代器；如果不存在这个关键码，就返回尾迭代器。

#### 30、**STL中list与queue之间的区别**

- ① list不再能够像vector一样以普通指针作为迭代器，因为其节点不保证在存储空间中连续存在；
- ②list插入操作和接合操作都不会造成原有的list迭代器失效;
- ③ list不仅是一个双向链表，而且还是一个环状双向链表，所以它只需要一个指针；
- ④ list不像vector那样有可能在空间不足时做重新配置、数据移动的操作，所以插入前的所有迭代器在插入操作之后都仍然有效；
- ⑤ deque是一种双向开口的连续线性空间，所谓双向开口，意思是可以在头尾两端分别做元素的插入和删除操作；
- ⑥ deque和vector最大的差异，一在于deque允许常数时间内对起头端进行元素的插入或移除操作，二在于deque没有所谓容量概念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，deque没有所谓的空间保留功能。

#### 31、**set和map的区别，multimap和multiset区别**

- set只提供一种数据类型的接口，但是它会将这一个元素分配到key和value上，而且它的compare_function用的是identity函数，这个函数是输入什么就输出什么，这样就实现了set机制，set的key和value是一样的，它保存的是两份数据，而不是一份数据
- map提供了两种数据类型的接口，分别分配到key和value上，它的compare_function采用的是红黑树的compare_function，它保存的是两份数据
- 它们两个的insert都是红黑树的insert_unique()独一无二的插入
- multimap和map唯一的区别就是：multimap调用的是insert_equal()可以重复插入，map调用的是独一无二的插入，set和multiset也一样，只是再插入的时候调用的方法不一样，底层实现都一样。

#### 32、**hashtable中解决冲突的方法？**

**开链法**：每个桶维护一条list，如果哈希函数计算出的桶相同，则按顺序存在这个list中。

**再散列**：发生冲突时使用另一种哈希函数再计算一个地址，直到不冲突

**线性探测**：使用哈希函数计算出的位置如果已经由元素占用了，则向后依次寻找，找到表尾则回到表头，直到找到一个空位。

**二次探测**：使用hash函数计算出的位置如果已经有元素占用了，按照1^2、2^2、3^2...的步长依次寻找，如果步长是随机数序列，则称之为伪随机探测

**公共溢出区**：一旦hash函数计算的结果相同，就放入公共溢出区

#### 33、**容器内部删除一个元素**

- ① 顺序容器（序列式容器，比如vector、deque）
  - erase迭代器不仅使所指向被删除的迭代器失效，而且使被删元素之后的所有迭代器失效(list除外)，所以不能使用erase(it++)的方式，但是erase的返回值是下一个有效迭代器；
- ② 关联容器(关联式容器，比如map、set、multimap、multiset等)
  - erase迭代器只是被删除元素的迭代器失效，但是返回值是void，所以要采用erase(it++)的方式删除迭代器；

#### 34、STL中hash_map扩容发生什么？

1. hash table表格内的元素称为桶（bucket),而由桶所链接的元素称为节点（node),其中存入桶元素的容器为stl本身很重要的一种序列式容器——vector容器。之所以选择vector为存放桶元素的基础容器，主要是因为vector容器本身具有动态扩容能力，无需人工干预。
2. 向前操作：首先尝试从目前所指的节点出发，前进一个位置（节点），由于节点被安置于list内，所以利用节点的next指针即可轻易完成前进操作，如果目前正巧是list的尾端，就跳至下一个bucket身上，那正是指向下一个list的头部节点。

#### 35、**STL迭代器讲一下**

1. Iterator（迭代器）模式又称游标（Cursor）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。 或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。 由于Iterator模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如STL的list、vector、stack等容器类及ostream_iterator等扩展Iterator。
2. 迭代器是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器，除此之外，STL中迭代器一个最重要的作用就是作为容器与STL算法的粘合剂。
3. 迭代器的作用就是提供一个遍历容器内部所有元素的接口，因此迭代器内部必须保存一个与容器相关联的指针，然后重载各种运算操作来遍历，其中最重要的是*运算符与->运算符，以及++、--等可能需要重载的运算符重载。这和C++中的智能指针很像，智能指针也是将一个指针封装，然后通过引用计数或是其他方法完成自动释放内存的功能。
4. 最常用的迭代器的相应型别有五种：value type、difference type、pointer、reference、iterator catagoly;

#### 36、**迭代器用过吗？什么时候会失效？**

用过，常用容器迭代器失效情形如下:

1. 对于序列容器vector，deque来说，使用erase后，后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器。

2. 对于关联容器map，set来说，使用了erase后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素，不会影响下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。

3. 对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的迭代器，因此上面两种方法都可以使用。

#### 37、**说一下STL中迭代器的作用，有指针为何还要迭代器？**

1. 迭代器的作用
   - 用于指向顺序容器和关联容器中的元素
   - 通过迭代器可以读取它指向的元素
   - 通过非const迭代器还可以修改其指向的元素

2. 迭代器和指针的区别
   - 迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，重载了指针的一些操作符，-->、++、--等。迭代器封装了指针，是一个”可遍历STL（ Standard TemplateLibrary）容器内全部或部分元素”的对象，本质是封装了原生指针，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，--等操作。迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用取值后的值而不能直接输出其自身。

3. 迭代器产生的原因
   - Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。

#### 38、**说说 STL 迭代器是怎么删除元素的**

1. 对于序列容器vector，deque来说，使用erase后，后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器；

2. 对于关联容器map，set来说，使用了erase后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素，不会影响下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可；

3. 对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的迭代器，因此上面两种方法都可以使用。 

#### 39、**说说 push_back 和 emplace_back 的区别**

- 如果要将一个临时变量push到容器的末尾，push_back()需要先构造临时对象，再将这个对象拷贝到容器的末尾，而emplace_back()则直接在容器的末尾构造对象，这样就省去了拷贝的过程。


#### 40、**说说 STL 容器动态链接可能产生的问题？**

1. 可能产生的问题
   - 容器是一种动态分配内存空间的一个变量集合类型变量。在一般的程序函数里，局部容器，参数传递容器，参数传递容器的引用，参数传递容器指针都是可以正常运行的，而在动态链接库函数内部使用容器也是没有问题的，但是给动态库函数传递容器的对象本身，则会出现内存堆栈破坏的问题。


2. 产生问题的原因
   - 容器和动态链接库相互支持不够好，动态链接库函数中使用容器时，参数中只能传递容器的引用，并且要保证容器的大小不能超出初始大小，否则导致容器自动重新分配，就会出现内存堆栈破坏问题。


#### 41、**说说 STL 中 resize 和 reserve 的区别**

1. 首先必须弄清楚两个概念：
   - capacity：该值在容器初始化时赋值，指的是容器能够容纳的最大的元素的个数。还不能通过下标等访问，因为此时容器中还没有创建任何对象。
   - size：指的是此时容器中实际的元素个数。可以通过下标访问0-(size-1)范围内的对象。

2. resize和reserve区别主要有以下几点：
   - resize既分配了空间，也创建了对象；reserve表示容器预留空间，但并不是真正的创建对象，需要通过insert（）或push_back（）等创建对象。
   - resize既修改capacity大小，也修改size大小；reserve只修改capacity大小，不修改size大小。
   - 两者的形参个数不一样。 resize带两个参数，一个表示容器大小，一个表示初始值（默认为0）；reserve只带一个参数，表示容器预留的大小。

**问题延伸：**

- resize 和 reserve 既有差别，也有共同点。两个接口的共同点是它们都保证了vector的空间大小(capacity)最少达到它的参数所指定的大小。下面就他们的细节进行分析。
- 为实现resize的语义，resize接口做了两个保证：
  - 保证区间[0, new_size)范围内数据有效，如果下标index在此区间内，vector[indext]是合法的；
  - 保证区间[0, new_size)范围以外数据无效，如果下标index在区间外，vector[indext]是非法的。
- reserve只是保证vector的空间大小(capacity)最少达到它的参数所指定的大小n。在区间[0, n)范围内，如果下标是index，vector[index]这种访问有可能是合法的，也有可能是非法的，视具体情况而定。

#### 42、**简单说一下traits技法**

traits技法利用“内嵌型别“的编程技巧与编译器的template参数推导功能，增强C++未能提供的关于型别认证方面的能力。常用的有iterator_traits和type_traits。

**iterator_traits**：被称为特性萃取机，能够方便的让外界获取以下5种型别：

- value_type：迭代器所指对象的型别
- difference_type：两个迭代器之间的距离
- pointer：迭代器所指向的型别
- reference：迭代器所引用的型别
- iterator_category：一共有5种分别为：
  1. input_iterator：istream独有的迭代器。
  2. output_iterator：ostream独有的迭代器。
  3. forward_iterator：继承自input_iterator，单向走的迭代器，只能走一个，不能跳。如forward_list、单向list的hashtable
  4. bidirectional_iterator：继承自forward_iterator，双向走的迭代器，只能走一个，不能跳。如list、rb-tree、双向list的hashtable
  5. random_access_iterator：继承自bidirectional_iterator，可以跳的迭代器。如array、vector、deque。

#### 44、**请你来介绍一下 STL 的空间配置器（allocator）**

一般情况下,一个程序包括数据结构和相应的算法，而数据结构作为存储数据的组织形式，与内存空间有着密切的联系。在C++ STL中，空间配置器便是用来实现内存空间(一般是内存，也可以是硬盘等空间)分配的工具，他与容器联系紧密，每一种容器的空间分配都是通过空间分配器alloctor实现的。

1. 两种C++类对象实例化方式的异同

在c++中，创建类对象一般分为两种方式：一种是直接利用构造函数,直接构造类对象，如 Test

test()；另一种是通过new来实例化一个类对象，如 Test *pTest = new Test；那么，这两种方式有

什么异同点呢？

我们知道，内存分配主要有三种方式：

（1） 静态存储区分配：内存在程序编译的时候已经分配好，这块内存在程序的整个运行空间内都存在。如全局变量,静态变量等。

（2） 栈空间分配：程序在运行期间，函数内的局部变量通过栈空间来分配存储（函数调用栈），当函数执行完毕返回时，相对应的栈空间被立即回收。主要是局部变量。

（3）堆空间分配：程序在运行期间，通过在堆空间上为数据分配存储空间，通过malloc和new创建的对象都是从堆空间分配内存，这类空间需要程序员自己来管理，必须通过free()或者是delete()函数对堆空间进行释放，否则会造成内存溢出。

那么，从内存空间分配的角度来对这两种方式的区别，就比较容易区分: 

（1）对于第一种方式来说，是直接通过调用Test类的构造函数来实例化Test类对象的,如果该实例化对象是一个局部变量，则其是在栈空间分配相应的存储空间。

（2）对于第二种方式来说,就显得比较复杂。这里主要以new类对象来说明一下。new一个类对象,其实是执行了两步操作：首先,调用new在堆空间分配内存,然后调用类的构造函数构造对象的内容；同样，使用delete释放时，也是经历了两个步骤：首先调用类的析构函数释放类对象，然后调用delete释放堆空间。

\2. C++ STL空间配置器实现

很容易想象，为了实现空间配置器，完全可以利用new和delete函数并对其进行封装实现STL的空间配置器，的确可以这样。但是，为了最大化提升效率，SGI STL版本并没有简单的这样做，而是采取了一定的措施，实现了更加高效复杂的空间分配策略。由于以上的构造都分为两部分，所以，在SGI STL中，将对象的构造切分开来，分成空间配置和对象构造两部分。

内存配置操作: 通过alloc::allocate()实现

内存释放操作: 通过alloc::deallocate()实现

对象构造操作: 通过::construct()实现

对象释放操作: 通过::destroy()实现

关于内存空间的配置与释放，SGI STL采用了两级配置器：一级配置器主要是考虑大块内存空间，利用malloc和free实现；二级配置器主要是考虑小块内存空间而设计的（为了最大化解决内存碎片问题，进而提升效率），采用链表free_list来维护内存池（memory pool），free_list通过union结构实现，空闲的内存块互相挂接在一块，内存块一旦被使用，则从链表中剔除，易于维护。

46、**STL的两级****空间****配置器**

为什么需要二级空间配置器？

我们知道动态开辟内存时，要在堆上申请，但若是我们需要频繁的在堆开辟释放内存，则就会在堆上造成很多外部碎片，浪费了内存空间；

每次都要进行调用malloc、free函数等操作，使空间就会增加一些附加信息，降低了空间利用率；随着外部碎片增多，内存分配器在找不到合适内存情况下需要合并空闲块，浪费了时间，大大降低了效率。

于是就设置了二级空间配置器，当开辟内存<=128bytes时，即视为开辟小块内存，则调用二级空间配置器。关于STL中一级空间配置器和二级空间配置器的选择上，一般默认选择的为二级空间配置器。 如果大于128字节再转去一级配置器器。

**一级配置器**

一级空间配置器中重要的函数就是allocate、deallocate、reallocate 。 一级空间配置器是以malloc()，free()，realloc()等C函数执行实际的内存配置 。大致过程是：

1、直接allocate分配内存，其实就是malloc来分配内存，成功则直接返回，失败就调用处理函数

2、如果用户自定义了内存分配失败的处理函数就调用，没有的话就返回异常

3、如果自定义了处理函数就进行处理，完事再继续分配试试

![img](file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml8644\wps12.jpg) 

二级配置器

1、维护16条链表，分别是0-15号链表，最小8字节，以8字节逐渐递增，最大128字节，你传入一个字节参数，表示你需要多大的内存，会自动帮你校对到第几号链表（如需要13bytes空间，我们会给它分配16bytes大小），在找到第n个链表后查看链表是否为空，如果不为空直接从对应的free_list中拔出，将已经拨出的指针向后移动一位。

2、对应的free_list为空，先看其内存池是不是空时，如果内存池不为空：

（1）先检验它剩余空间是否够20个节点大小（即所需内存大小(提升后) * 20），若足够则直接从内存池中拿出20个节点大小空间，将其中一个分配给用户使用，另外19个当作自由链表中的区块挂在相应的free_list下，这样下次再有相同大小的内存需求时，可直接拨出。

（2）如果不够20个节点大小，则看它是否能满足1个节点大小，如果够的话则直接拿出一个分配给用户，然后从剩余的空间中分配尽可能多的节点挂在相应的free_list中。

（3）如果连一个节点内存都不能满足的话，则将内存池中剩余的空间挂在相应的free_list中（找到相应的free_list），然后再给内存池申请内存，转到3。 

3、内存池为空，申请内存 此时二级空间配置器会使用malloc()从heap上申请内存，（一次所申请的内存大小为2 * 所需节点内存大小（提升后）* 20 + 一段额外空间），申请40块，一半拿来用，一半放内存池中。

4、malloc没有成功 在第三种情况下，如果malloc()失败了，说明heap上没有足够空间分配给我们了，这时，二级空间配置器会从比所需节点空间大的free_list中一一搜索，从比它所需节点空间大的free_list中拔除一个节点来使用。如果这也没找到，说明比其大的free_list中都没有自由区块了，那就要调用一级适配器了。

释放时调用deallocate()函数，若释放的n>128，则调用一级空间配置器，否则就直接将内存块挂上自由链表的合适位置。

STL二级空间配置器虽然解决了外部碎片与提高了效率，但它同时增加了一些缺点：

① 因为自由链表的管理问题，它会把我们需求的内存块自动提升为8的倍数，这时若你需要1个字节，它会给你8个字节，即浪费了7个字节，所以它又引入了内部碎片的问题，若相似情况出现很多次，就会造成很多内部碎片；

② 二级空间配置器是在堆上申请大块的狭义内存池，然后用自由链表管理，供现在使用，在程序执行过程中，它将申请的内存一块一块都挂在自由链表上，即不会还给操作系统，并且它的实现中所有成员全是静态的，所以它申请的所有内存只有在进程结束才会释放内存，还给操作系统，由此带来的问题有：

\1) 即我不断的开辟小块内存，最后整个堆上的空间都被挂在自由链表上，若我想开辟大块内存就会失败；

\2) 若自由链表上挂很多内存块没有被使用，当前进程又占着内存不释放，这时别的进程在堆上申请不到空间，也不可以使用当前进程的空闲内存，由此就会引发多种问题。

一级分配器

GC4.9之后就没有第一级了，只有第二级

二级分配器

——default_alloc_template 剖析

有个自动调整的函数：你传入一个字节参数，表示你需要多大的内存，会自动帮你校对到第几号链表（0-15号链表，最小8字节 最大128字节）

allocate函数：如果要分配的内存大于128字节，就转用第一级分配器，否则也就是小于128字节。那么首先判断落在第几号链表，定位到了，先判断链表是不是空，如果是空就需要充值，（调节到8的倍数，默认一次申请20个区块，当然了也要判断20个是不是能够申请到，如果只申请到一个那就直接返回好了，不止一个的话，把第2到第n个挨个挂到当前链表上，第一个返回回去给容器用,n是不大于20的，当然了如果不在1-20之间，那就是内存碎片了，那就先把碎片挂到某一条链表上，然后再重新malloc了，malloc 2*20个块）去内存池去拿或者重新分配。不为空的话

47、**STL中的allocator、deallocator**

① 第一级配置器直接使用malloc()、free()和relloc()，第二级配置器视情况采用不同的策略：当配置区块超过128bytes时，视之为足够大，便调用第一级配置器；当配置器区块小于128bytes时，为了降低额外负担，使用复杂的内存池整理方式，而不再用一级配置器；

② 第二级配置器主动将任何小额区块的内存需求量上调至8的倍数，并维护16个free-list，各自管理大小为8~128bytes的小额区块；

③ 空间配置函数allocate()，首先判断区块大小，大于128就直接调用第一级配置器，小于128时就检查对应的free-list。如果free-list之内有可用区块，就直接拿来用，如果没有可用区块，就将区块大小调整至8的倍数，然后调用refill()，为free-list重新分配空间；

④ 空间释放函数deallocate()，该函数首先判断区块大小，大于128bytes时，直接调用一级配置器，小于128bytes就找到对应的free-list然后释放内存。

48、**STL中的heap的实现**

heap（堆）并不是STL的容器组件，是priority queue（优先队列）的底层实现机制，因为binary max heap（大根堆）总是最大值位于堆的根部，优先级最高。

binary heap本质是一种complete binary tree（完全二叉树），整棵binary tree除了最底层的叶节点之外，都是填满的，但是叶节点从左到右不会出现空隙，如下图所示就是一颗完全二叉树

![img](file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml8644\wps13.jpg) 

完全二叉树内没有任何节点漏洞，是非常紧凑的，这样的一个好处是可以使用array来存储所有的节点，因为当其中某个节点位于i处，其左节点必定位于2i处，右节点位于2i+1处，父节点位于i/2（向下取整）处。这种以array表示tree的方式称为隐式表述法。

因此我们可以使用一个array和一组heap算法来实现max heap（每个节点的值大于等于其子节点的值）和min heap（每个节点的值小于等于其子节点的值）。由于array不能动态的改变空间大小，用vector代替array是一个不错的选择。

那heap算法有哪些？常见有的插入、弹出、排序和构造算法，下面一一进行描述。

***\*push_heap插入算法\****

由于完全二叉树的性质，新插入的元素一定是位于树的最底层作为叶子节点，并填补由左至右的第一个空格。事实上，在刚执行插入操作时，新元素位于底层vector的end()处，之后是一个称为percolate up（上溯）的过程，举个例子如下图：

![img](file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml8644\wps14.jpg) 

新元素50在插入堆中后，先放在vector的end()存着，之后执行上溯过程，调整其根结点的位置，以便满足max heap的性质，如果了解大根堆的话，这个原理跟大根堆的调整过程是一样的。

***\*pop_heap算法\****

heap的pop操作实际弹出的是根节点吗，但在heap内部执行pop_heap时，只是将其移动到vector的最后位置，然后再为这个被挤走的元素找到一个合适的安放位置，使整颗树满足完全二叉树的条件。这个被挤掉的元素首先会与根结点的两个子节点比较，并与较大的子节点更换位置，如此一直往下，直到这个被挤掉的元素大于左右两个子节点，或者下放到叶节点为止，这个过程称为percolate down（下溯）。举个例子：

![img](file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml8644\wps15.jpg) 

根节点68被pop之后，移到了vector的最底部，将24挤出，24被迫从根节点开始与其子节点进行比较，直到找到合适的位置安身，需要注意的是pop之后元素并没有被移走，如果要将其移走，可以使用pop_back()。

***\*sort算法\****

言以蔽之，因为pop_heap可以将当前heap中的最大值置于底层容器vector的末尾，heap范围减1，那么不断的执行pop_heap直到树为空，即可得到一个递增序列。

***\*make_heap算法\****

将一段数据转化为heap，一个一个数据插入，调用上面说的两种percolate算法即可。

#### 49、**如何在共享内存上使用STL标准库？**

1.想像一下把STL容器，例如map, vector, list等等，放入共享内存中，IPC一旦有了这些强大的通用数据结构做辅助，无疑进程间通信的能力一下子强大了很多。

我们没必要再为共享内存设计其他额外的数据结构，另外，STL的高度可扩展性将为IPC所驱使。STL容器被良好的封装，默认情况下有它们自己的内存管理方案。

当一个元素被插入到一个STL列表(list)中时，列表容器自动为其分配内存，保存数据。考虑到要将STL容器放到共享内存中，而容器却自己在堆上分配内存。

一个最笨拙的办法是在堆上构造STL容器，然后把容器复制到共享内存，并且确保所有容器的内部分配的内存指向共享内存中的相应区域，这基本是个不可能完成的任务。

2.假设进程A在共享内存中放入了数个容器，进程B如何找到这些容器呢？

一个方法就是进程A把容器放在共享内存中的确定地址上（fixed offsets），则进程B可以从该已知地址上获取容器。另外一个改进点的办法是，进程A先在共享内存某块确定地址上放置一个map容器，然后进程A再创建其他容器，然后给其取个名字和地址一并保存到这个map容器里。

进程B知道如何获取该保存了地址映射的map容器，然后同样再根据名字取得其他容器的地址。

#### 42、**解释一下什么是trivial destructor？**

trivial destructor一般指的是用户没有自定义的析构函数，在《STL源码剖析》中被称为无关痛痒的析构函数。

相反的non trivial destructor指的是用户自定义的析构函数，这种析构函数如果申请新的内存空间一定要显示的释放，否则会造成内存泄漏。

**对于trivial destructor，如果每次都进行调用，显然是对效率的一种伤害，如何进行判断呢？**

在《STL源码剖析》中给出说明：

可以利用value_type()获取所指对象的型别，再利用_type_trivial判断该型别是否trivial，若是_type_true，什么也不做，若是_type_false就调用destrory()函数	

44、**迭代器：++it、it++哪个好，为什么**

① 前置返回一个引用，后置返回一个对象

// ++i实现代码为：int& operator++(){

 

 *this += 1;

 return *this;

}

② 前置不会产生临时对象，后置必须产生临时对象，临时对象会导致效率降低

//i++实现代码为：         

int operator++(int)         

{

int temp = *this;          

  ++*this;            

return temp; 	        

}