#### 一、**面向对象的三大特性**

#### 1、**简述一下什么是面向对象**

1. 面向对象是一种编程思想，把一切东西看成是一个个对象，比如人、耳机、鼠标、水杯等，他们各自都有属性，比如：耳机是白色的，鼠标是黑色的，水杯是圆柱形的等等，把这些对象拥有的属性变量和操作这些属性变量的函数打包成一个类来表示

2. 面向过程和面向对象的区别
   - **面向过程：根据业务逻辑从上到下写代码**
   - **面向对象：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程**

#### 2、**简述一下面向对象的三大特征**

面向对象的三大特征是**封装、继承、多态**

1. 封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。封装本质上是一种管理：我们如何管理兵马俑呢？比如如果什么都不管，兵马俑就被随意破坏了。那么我们首先建了一座房子把兵马俑给封装起来。但是我们目的全封装起来，不让别人看。所以我们开放了售票通道，可以买票突破封装在合理的监管机制下进去参观。类也是一样，不想给别人看到的，我们使用protected/private把成员封装起来。开放一些共有的成员函数对成员合理的访问。所以封装本质是一种管理。

2. 继承：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

   - 三种继承方式

   | 继承方式            | private继承     | protected继承     | public继承        |
   | ------------------- | --------------- | ----------------- | ----------------- |
   | 基类的private成员   | 不可见          | 不可见            | 不可见            |
   | 基类的protected成员 | 变为private成员 | 仍为protected成员 | 仍为protected成员 |
   | 基类的public成员    | 变为private成员 | 变为protected成员 | 仍为public成员    |

![image-20220815091057456](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220815091057456.png) 

3. 多态：用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。实现多态，有二种方式，重写，重载。

#### 3、讲一下面向对象的三大特性

<u>封装、继承、多态</u>

**继承**

- 让某种类型对象获得另一个类型对象的属性和方法。	
- 它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。
- **常见继承：**
  1. 实现继承：指使用基类的属性和方法而无需额外编码的能力
  2. 接口继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力
  3. 可视继承：指子窗体（类）使用基窗体（类）的外观和实现代码的能力

**封装**

- 数据和代码绑定到一起，避免外界干扰和不确定性访问。
- 封装，也就是把客观事务封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对可信的进行隐藏，如将公共数据设置为public修饰，而不希望被访问到的用private修饰。

**多态**

- **同一事物表现出不同事物的能力**，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为，**重载实现编译时的多态，虚函数实现运行时的多态。**
- 多态性是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给子对象的特性以不同的方式运作。简单一句话：允许将子类类型的指针赋值给父类类型的指针
- 实现多态有两种方式：覆盖、重载
  - **覆盖：是指子类重新定义父类的虚函数的说法。**
  - **重载：是指允许存在多个同名函数，而这些函数的参数表不同（参数个数或者参数类型不同，或两者皆不同）。**

#### **4、**什么是类的继承？

**类与类之间存在的关系**

1. **包含关系**—(has-A)，用以描述一个类由多个部件类构成，实现has-A关系用类的成员属性表示，即一个类的成员属性是另一个已经定义好的类；
2. **一个类使用另一个类(use-A)**，通过类之间的成员函数相互联系，定义友元或者通过传递参数的方式来实现；
3. **继承关系(is-A)**，关系具有传递性；

**继承的相关概念**

- 所谓的继承就是一个类继承了另一个类的属性和方法，这个新的类包含了上一个类的属性和方法，被称为子类或者派生类，被继承的类称为父类或者基类；


**继承的特点**

- 子类拥有父类的所有属性和方法，子类可以拥有父类没有的属性和方法，子类对象可以当做父类对象使用；


**继承中的访问控制**

- public、protected、private
- 继承中的构造和析构函数
- 继承中的兼容性原则

#### 5、**C++的多态**怎么实现

**C++的多态性：**

- 就是在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据所指对象的实际类型来调用相应的函数，如果对象类型是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数。


**虚表和虚表指针：**

- 虚表：虚函数表的缩写，类中含有virtual关键字修饰的方法时，编译器会自动生成虚表。
- 虚表指针：在含有虚函数的类实例化对象时，对象地址的前四个字节存储的指向虚表的指针。

**多态实现的过程：**

1. 编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是一个一维数组，虚表里面保存了虚函数的入口地址。
2. 编译器会在每个对象的前4个字节中保存一个虚表指针，即vptr，指向对象所属类的虚表。在构造时，根据对象的类型去初始化虚指针vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数
3. 所谓的合适时机，在派生类定义对象时，程序会自动调用构造函数，<u>在构造函数中创建虚表并对虚表进行初始化</u>，在构造子类对象时，会先调用父类的构造函数，此时，编译器只看到了父类，并为父类初始化虚表指针，令它指向父类的虚表，当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表。
4. 当派生类对基类的虚函数没有进行重写，派生类的虚表指针指向的是基类的虚表，当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表，当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面。
5. 这样指向派生类的基类指针运行时，就可以根据派生类对虚函数重写情况动态的进行调用，从而实现多态性。

#### 6、**为什么析构函数一般写成虚函数？**

- 由于类的多态性，基类指针能够指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放，
- 如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类的析构函数，这样会造成派生类对象析构不完全，造成内存泄漏。
- 所以将析构函数声明为虚函数是十分必要的，在实现多态时，当用基类操作派生类，在析构时防止只析构基类不析构派生类的状况发生，要将基类的析构函数声明为虚函数。

#### 7、**构造函数是否声明为虚函数或纯虚函数，析构函数呢？**

- **构造函数不可以声明为虚函数**，但在构造函数中可以调用虚函数，且调用的是正在构造的类的虚函数，而不是子类的虚函数，因为此时子类尚未构造好。
- 虚函数对应一个虚函数表，类中存储一个vptr指向这个虚函数表vtable，如果构造函数是虚函数，就需要通过vtable调用，但是**对象没有初始化就没有vptr所以构造函数不能是虚函数。**
- **析构函数可以定义为虚函数**，并且一般情况下，基类析构函数需要定义为虚函数。
- 只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象基类的指针时，才能准确的调用派生类的析构函数，才能准确销毁对象。
- **析构函数可以是纯虚函数**，含有纯虚函数的类是抽象类，此时不能被实例化，但派生类可以根据自己的需求重新改写基类中的纯虚函数。

#### 8、**基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间**

**虚函数表的特征：**

- 虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成
- 虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码段。
- 虚函数表存储虚函数的地址，即虚函数表的元素是指向类成员函数的指针，而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定，即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中。所以**虚函数表类似于类中静态成员变量也是全局共享，大小确定，因此最有可能存储在全局数据区。**

**虚函数表在linux/unix中存放在可执行文件的只读数据段中（rodata），这与微软的编译器将vtable存放在常量段有所区别。**

虚表指针vptr和虚函数密不可分，对于有虚函数或者继承于拥有虚函数的基类，对该类进行实例化时，在构造函数执行时会对虚表指针进行初始化，并且存在对象内存的最前面。

一般分为五个区域：栈、堆、函数区、全局静态、常量区

**C++虚函数表位于只读数据段（.rodata)，也就是c++内存模型中的常量区，而虚函数则位于代码段（.text），也就是C++内存模型中的代码区。**

#### 9、**模板函数和模板类的特例化**

引入原因：

- 单一模板，能适应多种类型的需求，使每种类型都具有相同功能，但对于某种特定类型。如果要实现其特有功能，单一模板无法做到，这时就需要模板特例化


**定义：**

- **对单一模板提供的一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值上。**

#### 10、构造函数、析构函数、虚函数是否声明为内联函数？

首先，将这些函数声明为内联函数，在语法上没有错误。因为inline同register一样，只是个建议，编译器并以一定真正的内联。

- **Register关键字：要求编译器尽可能的将变量存到CPU内部寄存器中，而不是通过内存寻址访问，以提高效率。**

**构造函数和析构函数声明为内联函数是没有意义的：**

- 《Effective C++》中所阐述的是：将构造函数和析构函数声明为inline是没有什么意义的，即编译器并不真正对声明为inline的构造和析构函数进行内联操作，**因为编译器会在构造和析构函数中添加额外的操作（申请/释放内存，构造/析构函数），致使构造函数/析构函数并不像看上去的那么精简。其次class中的函数默认是inline型的，编译器也只是有选择性的内联，将构造函数和析构函数声明为内联函数是没有什么意义的。**

**将虚函数声明为inline，要分情况讨论**：

- 当是指向派生类的指针（多态性）调用声明为inline的虚函数时，不会内联展开；当是对象本身用虚函数时，会内联展开，前提是函数并不复杂的情况下。


#### 11、**C++模板是什么，你知道底层怎么实现？**

- 编译器并不是把函数模板处理成能够处理任意类的函数，编译器从函数模板通过具体类型产生不同的函数，编译器会对函数模板进行两次编译，在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。
- 这是因为函数模板要被实例化后才能成为真正的函数，在使函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。

#### 12、构造函数为什么不能为虚函数，析构函数为什么要是虚函数？

1. 从存储空间角度，虚函数相应一个指向vtable的指针，但是这个指向vtable的指针事实上是存储在对象的内存空间的。如果构造函数是虚的，就必须通过vtable调用，但对象还没有实例化，也就是内存空间还没有，所以构造函数不能为虚函数。
2. 使用角度：虚函数主要用于在信息不全的情况下，能使重载的函数得到相应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义。
3. 构造函数不需要为虚函数，也无需为虚函数
4. 从实现上，
5. ...

#### 13、**析构函数的作用，如何起作用？**

1. **构造函数只是起初始化值的作用**；但实例化一个对象时，可以通过实例去传递参数，从主函数传递到其他的函数里面，这样就使其他的函数里面有值了。
   - 规则：只要你一实例化对象，系统自动调用一个构造函数，即使你不写，编译器也会自动调用一次。
2. **析构函数与构造函数作用相反，用于撤销对象的一些特殊任务处理，可以是释放对象分配的内存空间**;特点：析构函数与构造函数同名，但该函数前加~。
3. 析构函数没有参数，没有返回值，不能重载，在一个类中只能有一个析构函数。撤销对象时，编译器会自动调用析构函数。
4. 每一个类必须有一个析构函数，用户可以自定义析构函数，也可以是编译器自动生成默认的析构函数。一般析构函数定义为类的公有成员。

#### 14、**构造函数和析构函数可以调用虚函数吗，为什么？**

1. 在C++中，提倡不在构造函数和析构函数中调用虚函数。
2. 构造函数和析构函数调用虚函数时都不使用动态联编，如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数和析构函数自身类型定义的版本。
3. 因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数是不安全的，故而C++不会进行动态联编。
4. 析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后调用基类的析构函数，所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数无意义。

#### 15、**构造函数、析构函数执行顺序？构造函数和拷贝构造的内部都干了啥？**

1）**构造函数执行顺序**

1. **基类构造函数**，如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。
2. **成员类对象构造函数**，如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。
3. **派生类构造函数**

2）析构函数的顺序

- 调用派生类的析构函数->调用成员类对象的析构函数->调用基类的析构函数


#### 16、**虚析构函数的作用，父类的析构函数是否要设置为虚函数？**

**1）****C++中基类采样虚析构函数是为了防止内存泄漏\****

如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。

***\*假设基类中采用非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。就会产生内存泄漏。\****

2）纯虚析构函数一定要定义，因为每一个派生类析构函数会被编译器加以扩张，以静态调用的方式调用其每一个虚基类以及上一层基类的析构函数。

缺乏任何一个基类析构函数的定义，就会导致链接失败，最好不用把虚析构函数定义为纯虚析构函数。

#### 17、**构造函数析构函数可否抛出异常**

1. **C++只会析构已经完成的对象**，对象只有在其构造函数执行完毕才算是完全构造妥当。在构造函数中发生异常，控制权转出构造函数之外。因此，在对象b的构造函数中发生异常，对象b的析构函数不会被调用。因此会造成内存泄漏。
2. 用auto_ptr对象来取代指针类成员，便对构造函数做了强化，免除了抛出异常时发生资源泄漏的危机，不再需要在析构函数中手动释放资源
3. 如果控制权基于异常的因素离开析构函数，而此时正有另一个异常处于作用状态，C++会调用terminate函数让程序结束
4. 如果异常从析构函数抛出，而且没有在当地进行捕捉，哪个析构函数便是执行不全的。如果析构函数执行不全，就是没有完成他应该执行的每一件事情。

#### 18、**构造函数一般不定义为虚函数的原因？**

1. 创建一个对象时需要确定对象的类型，而虚函数是在运行时动态确定其类型的。在构造一个对象时，由于对象还未创建成功，编译器无法确定对象的实际类型。
2. 虚函数的调用需要虚函数表指针vptr，而该指针存放在对象的内存空间中，若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表vtable地址用来调用虚构造函数了。
3. 虚函数的作用在于通过父类的指针或引用调用它的时候能够变成调用子类的那个成员函数，而构造函数是在创建对象时自动调用的，不可能通过父类或者引用去调用，因此就规定构造函数不能是虚函数。
4. 析构函数一般都要声明为虚函数。

#### 19、类什么时候析构？

1. 对象生命周期结束，销毁时。
2. delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类析构函数是虚函数。
3. 对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用。

#### 20、构造函数或者析构函数中可以调用虚函数吗？

- **语法上讲，调用完全没有问题。效果上看，往往不能达到需要的目的。**

- 《Effective C++》的解释是：派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型，同样，进入基类析构函数时，对象也是基类类型。


#### 21、构造函数的几种关键字

**default**

- default关键字可以显示要求编译器生成合成构造函数，防止在调用时相关构造函数类型没有定义而报错。

**delete**

- delete关键字可以删除构造函数、赋值运算符函数，这样在使用的时候会得到友善的提示。

**=0**

- 0将虚函数定义为纯虚函数

#### 22、**构造函数、拷贝构造函数和赋值操作符的区别**

**构造函数**

- 对象不存在，没有别的对象初始化，在创建一个新的对象时调用构造函数。


**拷贝构造函数**

- 对象不存在，但在使用别的已经存在的对象来进行初始化


**赋值运算符**

- 对象存在，用别对象给它赋值，这属于重载“=”的范畴，“=”两侧的对象均已存在


#### 23、**拷贝构造函数和赋值运算符重载的区别？**

拷贝构造函数是函数，赋值运算符是运算符重载。

拷贝构造函数会生成新的类对象，赋值运算符不能。

拷贝构造函数是直接构造一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同，赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉。

形参传递是调用拷贝构造函数，但并不是所有出现“=”的地方都是使用赋值运算符

注：类中有指针变量时需要重写析构函数，拷贝构造函数和赋值运算符

#### 24、**说说移动构造函数**

1. 我们用对象a初始化对象b，后对象a我们就不再使用了，但是对象a的空间还在（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷。
2. 拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采样浅层复制。浅层复制之所以危险是因为，两个指针指向同一块内存空间，若第一个指针将这块内存释放，第二个指针再释放就会报错，所以我们只要避免第一个指针释放空间就可以了。避免方法为：将第一个指针职位NULL，这样调用析构函数的时候，由于有判断是否为NULL的语句，所以析构a的时候并不会回收指针指向的内存空间。
3. 移动构造函数的参数和拷贝构造函数不同，**拷贝构造函数的参数是一个左值引用，移动构造函数的初值是一个右值引用**，意味着，移动构造函数的参数是一个右值或者将亡值的引用。也就是说，只要用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数，而那个**move语句就是将一个左值变为将亡值。**

#### 25、**什么是虚拟继承？**

- C++支持多继承，除了public、protected、private三种继承方式外，还提供虚拟virtual继承，如：b,c继承a,	d又公有继承b,c这种方式是一种菱形继承或者钻石继承。
- **虚拟继承的情况下，无论基类被继承多少次，只会存在一个实体。**
- 虚拟继承基类的子类中，子类会增加某种形式的指针，或者指向虚基类对象，或者指向一个相关的表格；表格中存放的不是虚基类子对象的地址，就是其偏移量，此类指针被称为bptr，如果即存在vptr又存在bptr，某些编译器会将其优化，合并为一个指针。

#### 26、**什么情况下会自动生成默认构造函数？**

1. 带有默认构造函数的类成员对象，如果一个类没有任何构造函数，但它含有一个成员对象，而后者有默认构造函数，那么编译器就会为该类合成一个默认构造函数。
2. 带有默认构造函数的基类，如果一个没有任务构造函数的派生类派生自一个带有默认构造函数基类，那么该派生类会合成一个构造函数调用上一层基类的默认构造函数。
3. 带有虚函数的类
4. 带有虚基类的类
5. 合成默认构造函数中，只有基类子对象和成员类对象会被初始化，所有其他的非静态数据成员都不会被初始化

#### **27、**如何阻止一个类被实例化？有哪些方法？

- 将类定义为抽象基类或者将构造函数声明为private；
- 不允许类外部创建类对象，只能在类内部创建对象

#### 28、C++中类成员的访问权限和继承权限问题

**三种访问权限**

1. public:用该关键字修饰的成员表示公有成员，该成员不仅可以在类内可以被访问，在类外也是可以被访问的，是类对外提供的可访问接口； 
2. private:用该关键字修饰的成员表示私有成员，该成员仅在类内可以被访问，在类体外是隐藏状态；
3. protected:用该关键字修饰的成员表示保护成员，保护成员在类体外同样是隐藏状态，但是对于该类的派生类来说，相当于公有成员，在派生类中可以被访问。

**三种继承方式**

1. 若继承方式是public，基类成员在派生类中的访问权限保持不变，也就是说，基类中的成员访问权限，在派生类中仍然保持原来的访问权限；
2. 若继承方式是private，基类所有成员在派生类中的访问权限都会变为私有(private)权限；
3. 若继承方式是protected，基类的共有成员和保护成员在派生类中的访问权限都会变为保护(protected)权限，私有成员在派生类中的访问权限仍然是私有(private)权限。

#### 29、为什么友元函数必须在类内部声明？

- 因为编译器必须能够读取这个结构的声明以理解这个数据类型的大小、行为等方面的所有规则。
- 有一条规则在任何关系中都很重要，那就是谁可以访问我的私有部分。
- **友元函数不一定要在类内声明，普通的友元函数可以在类外声明，也可以在类内声明。**

#### 30、友元函数和友元类的基本情况

友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。

**1）友元函数**

- 友元函数是定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。但是需要在类的定义中声明所有可以访问它的友元函数。
- 一个函数可以是多个类的友元函数，但是每个类中都要声明这个函数。

**2）友元类**

- 友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。但是另一个类里面也要相应的进行声明
- 使用友元类时注意：
  1. 友元关系不能被继承。
  2. 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。
  3. 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明

#### 31、成员函数里memset(this,0,sizeof(\*this))会发生什么

- 有时候类里面定义了很多int,char,struct等c语言里的那些类型的变量，我习惯在构造函数中将它们初始化为0，但是一句句的写太麻烦，所以直接就memset(this, 0, sizeof *this);将整个对象的内存全部置为0。对于这种情形可以很好的工作，但是下面几种情形是不可以这么使用的；
- 类含有虚函数表：这么做会破坏虚函数表，后续对虚函数的调用都将出现异常；
- 类中含有C++类型的对象：例如，类中定义了一个list的对象，由于在构造函数体的代码执行之前就对list对象完成了初始化，假设list在它的构造函数里分配了内存，那么我们这么一做就破坏了list对象的内存。

#### 32、C++中的重载、重写（覆盖）和隐藏的区别

**（1）重载（overload）**

- 重载是指在同一范围定义中的同名成员函数才存在重载关系。**主要特点是函数名相同，参数类型和数目有所不同**，不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。重载和函数成员是否是虚函数无关。


**（2）重写（覆盖）（override）**

- 重写指的是在派生类中覆盖基类中的同名函数，也就是重写函数体，其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类对象调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。

- 重载与重写的区别：
  - 重写是父类和子类之间的垂直关系，重载是不同函数之间的水平关系
  - 重写要求参数列表相同，重载则要求参数列表不同，返回值不要求
  - 重写关系中，调用方法根据对象类型决定，重载根据调用时实参表与形参表的对应关系来选择函数体

**（3）隐藏（hide）**

- 隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数，包括以下情况：
  - 两个函数参数相同，但是基类函数不是虚函数。和重写的区别在于基类函数是否是虚函数。
  - 两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中。

#### 33、什么是虚拟继承？

- C++支持多继承，除了public、protected、private三种继承方式外，还提供虚拟virtual继承，如：b,c继承a,	d又公有继承b,c这种方式是一种菱形继承或者钻石继承
- 虚拟继承的情况下，无论基类被继承多少次，只会存在一个实体。通过 virtual 关键字的修饰可以实现虚拟继承
- 虚拟继承基类的子类中，子类会增加某种形式的指针，或者指向虚基类对象，或者指向一个相关的表格；表格中存放的不是虚基类子对象的地址，就是其偏移量，此类指针被称为bptr，如果即存在vptr又存在bptr，某些编译器会将其优化，合并为一个指针。
- 在虚拟继承下，无论一个公共的基类子对象在派生类层次中出现了多少次，只会有一个共享的基类子对象被继承。共享的基类子对象被称为虚基类，在虚拟继承机制下，基类子对象的多份复制产生的二义性问题被消除了。

#### 34、类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？

- **赋值初始化**，通过在函数体内进行赋值初始化；
- **列表初始化**，在冒号后使用初始化列表进行初始化。

**这两种方式的主要区别在于：**

- 对于在函数体中初始化,是在所有的数据成员被分配内存空间后才进行的。
- 列表初始化是给数据成员分配内存空间时就进行初始化,就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式),那么分配了内存空间后在进入函数体之前给数据成员赋值，就是说初始化这个数据成员此时函数体还未执行。

**一个派生类构造函数的执行顺序如下：**

1. 虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）。
2. 基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）。
3. 类类型的成员对象的构造函数（按照初始化顺序）
4. 派生类自己的构造函数。

方法一是在构造函数当中做赋值的操作，而方法二是做纯粹的初始化操作。我们都知道，C++的赋值操作是会产生临时对象的。临时对象的出现会降低程序的效率。

#### 35、**如果想将某个类用作基类，为什么该类必须定义而非声明？**

- 派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必须知道他们是什么。所以必须定义而非声明。


#### 36、**继承机制中对象之间如何转换？指针和引用之间如何转换？**

**向上类型转换**

- **将派生类指针或引用转换为基类的指针或引用被称为向上类型转换**，向上类型转换会自动进行，而且向上类型转换是安全的。

**向下类型转换**

- **将基类指针或引用转换为派生类指针或引用被称为向下类型转换**，向下类型转换不会自动进行，因为一个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类，所以在向下类型转换时必须加动态类型识别技术。RTTI技术，用dynamic_cast进行向下类型转换。

#### 38、**知道C++中的组合吗？它与继承相比有什么优缺点吗？**

**一、继承**

- 继承是Is a的关系，比如说Student继承Person,则说明Student is a Person。继承的优点是子类可以重写父类的方法来方便地实现对父类的扩展。


继承的缺点有以下几点：

- ① 父类的内部细节对子类是可见的。
- ② 子类从父类继承的方法在编译时就确定下来了，所以无法在运行期间改变从父类继承的方法的行为。
- ③ 如果对父类的方法做了修改的话（比如增加了一个参数），则子类的方法必须做出相应的修改。所以说子类与父类是一种高耦合，违背了面向对象思想。

**二、组合**

组合也就是设计类的时候把要组合的类的对象加入到该类中作为自己的成员变量。

组合的优点：

- ① 当前对象只能通过所包含的那个对象去调用其方法，所以所包含的对象的内部细节对当前对象时不可见的。
- ② 当前对象与包含的对象是一个低耦合关系，如果修改包含对象的类中代码不需要修改当前对象类的代码。
- ③ 当前对象可以在运行时动态的绑定所包含的对象。可以通过set方法给所包含对象赋值。

组合的缺点：

- ① 容易产生过多的对象。
- ② 为了能组合多个对象，必须仔细对接口进行定义。

#### 39、final和override关键字

**Override**

- 指定了子类的这个虚函数是重写的父类的，如果你名字不小心打错了的话，编译器是不会编译通过的


**Final**

- 当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。


#### 40、拷贝初始化和直接初始化

- 当用于类类型对象时，初始化的拷贝形式和直接形式有所不同：直接初始化直接调用与实参匹配的构造函数，拷贝初始化总是调用拷贝构造函数。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象。


#### 41、有哪些情况必须用到成员列表初始化？作用是什么？

必须使用成员初始化的四种情况

- ① 当初始化一个引用成员时；
- ② 当初始化一个常量成员时；
- ③ 当调用一个基类的构造函数，而它拥有一组参数时；
- ④ 当调用一个成员类的构造函数，而它拥有一组参数时；

成员初始化列表做了什么

- ① 编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码之前；
- ② list中的项目顺序是由类中的成员声明顺序决定的，不是由初始化列表的顺序决定的；

#### 42、**成员初始化列表的概念，为什么用它会快一些？**

**成员初始化列表的概念**

- 在类的构造函数中，不在函数体内对成员变量赋值，而在构造函数的花括号前面使用冒号和初始化列表赋值


效率

- 用初始化列表效率更快，原因是：对于类型，它少一次调用构造函数的过程，而在函数体中赋值会多一次调用。而对于内置数据类型则没有差别。


#### 43、**C++有哪几种的构造函数**

C++中的构造函数可以分为4类：

- 默认构造函数
- 初始化构造函数（有参数）
- 拷贝构造函数
- 移动构造函数（move和右值引用）
- 委托构造函数
- 转换构造函数

默认构造函数和初始化构造函数在定义类的对象，完成对象的初始化工作

复制构造函数用于复制本类的对象

转换构造函数用于将其他类型的变量，隐式转换为本类对象

#### 44、**什么情况下会调用拷贝构造函数**

①用类的一个实例化对象去初始化另一个对象的时候

②函数的参数是类的对象时（非引用传递）

③**函数的返回值是函数体内局部对象的类的对象时** ,此时虽然发生（Named return Value优化）NRV优化，但是由于返回方式是值传递，所以会在返回值的地方调用拷贝构造函数

- 另：第三种情况在Linux g++ 下则不会发生拷贝构造函数，不仅如此即使返回局部对象的引用，依然不会发生拷贝构造函数


- 在c++编译器发生NRV优化，如果是引用返回的形式则不会调用拷贝构造函数，如果是值传递的方式依然会发生拷贝构造函数。


#### 45、**C++中类成员的访问权限和继承权限问题**

**三种访问权限**

- ① public:用该关键字修饰的成员表示公有成员，该成员不仅可以在类内可以被访问，在类外也是可以被访问的，是类对外提供的可访问接口；


- ② private:用该关键字修饰的成员表示私有成员，该成员仅在类内可以被访问，在类体外是隐藏状态；


- ③ protected:用该关键字修饰的成员表示保护成员，保护成员在类体外同样是隐藏状态，但是对于该类的派生类来说，相当于公有成员，在派生类中可以被访问。


**三种继承方式**

- ① 若继承方式是public，基类成员在派生类中的访问权限保持不变，也就是说，基类中的成员访问权限，在派生类中仍然保持原来的访问权限；
- ② 若继承方式是private，基类所有成员在派生类中的访问权限都会变为私有(private)权限；
- ③ 若继承方式是protected，基类的公有成员和保护成员在派生类中的访问权限都会变为保护(protected)权限，私有成员在派生类中的访问权限仍然是私有(private)权限。

#### 46、**如何阻止一个类被实例化？有哪些方法？**

- 将类定义为抽象基类或者将构造函数声明为private；
- 不允许类外部创建类对象，只能在类内部创建对象

#### 47、为什么模板类一般都是放在一个h文件中

- 模板定义很特殊。**由template<…>处理的任何东西都意味着编译器在当时不为它分配存储空间，它一直处于等待状态直到被一个模板实例告知。**在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。
- 所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。
- 在分离式编译的环境下，编译器编译某一个.cpp文件时并不知道另一个.cpp文件的存在，也不会去查找（当遇到未决符号时它会寄希望于连接器）。这种模式在没有模板的情况下运行良好，但遇到模板时就傻眼了，**因为模板仅在需要的时候才会实例化出来。**
- 所以，当编译器只看到模板的声明时，它不能实例化该模板，只能创建一个具有外部连接的符号并期待连接器能够将符号的地址决议出来。
- 然而当实现该模板的.cpp文件中没有用到模板的实例时，编译器懒得去实例化，所以，整个工程的.obj中就找不到一行模板实例的二进制代码，于是连接器也黔驴技穷了。

#### 48、**如何禁止程序自动生成拷贝构造函数？**

1. 为了阻止编译器默认生成拷贝构造函数和拷贝赋值函数，我们需要手动去重写这两个函数，某些情况下，为了避免调用拷贝构造函数和拷贝赋值函数，我们需要将他们设置成private，防止被调用。
2. 类的成员函数和friend函数还是可以调用private函数，如果这个private函数只声明不定义，则会产生一个连接错误；
3. 针对上述两种情况，**我们可以定一个base类，在base类中将拷贝构造函数和拷贝赋值函数设置成private,那么派生类中编译器将不会自动生成这两个函数，且由于base类中该函数是私有的，因此，派生类将阻止编译器执行相关的操作。**

#### 49、**抽象基类为什么不能创建对象？**

抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。

1. 抽象类的定义： 称带有纯虚函数的类为抽象类。
2. 抽象类的作用： 抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。所以派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。
3.  抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。抽象类是不能定义对象的。一个纯虚函数不需要（但是可以）被定义。
4. 纯虚函数定义 纯虚函数是一种特殊的虚函数，它的一般格式为：`class <类名> 　{ 　virtual <类型><函数名>(<参数表>)=0; 　… 　};` 
   - 在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。 　纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。凡是含有纯虚函数的类叫做抽象类。这种类不能声明对象，只是作为基类为派生类服务。除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。
5. 纯虚函数引入原因：
   1. 为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。
   2. 在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔 雀等子类，但动物本身生成对象明显不合常理。为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;）。若要使派生类为非抽象类，则编译器要求在派生类中，必须对纯虚函数予以重载以实现多态性。同时含有纯虚函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。 例如，绘画程序中，shape作为一个基类可以派生出圆形、矩形、正方形、梯形等， 如果我要求面积总和的话，那么会可以使用一个 shape * 的数组，只要依次调用派生类的area()函数了。如果不用接口就没法定义成数组，因为既可以是circle ,也可以是square ,而且以后还可能加上rectangle，等等.
6. 相似概念
   1. 多态性：指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。C++支持两种多态性：编译时多态性，运行时多态性。 　a.编译时多态性：通过重载函数实现 　b.运行时多态性：通过虚函数实现。
   2. 虚函数：虚函数是在基类中被声明为virtual，并在派生类中重新定义的成员函数，可实现成员函数的动态重载。
   3. 抽象类：包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象。

#### 50、**模板类和模板函数的区别是什么？**

- 函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显式地指定。即函数模板允许隐式调用和显式调用而类模板只能显示调用。在使用时类模板必须加<T>，而函数模板不必

#### 51、**多继承的优缺点，作为一个开发者怎么看待多继承**

- C++允许为一个派生类指定多个基类，这样的继承结构被称做多重继承。
- 多重继承的优点很明显，就是对象可以调用多个基类中的接口；
- 如果派生类所继承的多个基类有相同的基类，而派生类对象需要调用这个祖先类的接口方法，就会容易出现二义性
- 加上全局符确定调用哪一份拷贝。比如pa.Author::eat()调用属于Author的拷贝。
- 使用虚拟继承，使得多重继承类Programmer_Author只拥有Person类的一份拷贝。

#### 52、**模板和实现可不可以不写在一个文件里面？为什么？**

- 因为在编译时模板并不能生成真正的二进制代码，而是在编译调用模板类或函数的CPP文件时才会去找对应的模板声明和实现，在这种情况下编译器是不知道实现模板类或函数的CPP文件的存在，所以它只能找到模板类或函数的声明而找不到实现，而只好创建一个符号寄希望于链接程序找地址。
- 但模板类或函数的实现并不能被编译成二进制代码，结果链接程序找不到地址只好报错了。 《C++编程思想》第15章(第300页)说明了原因：模板定义很特殊。由template<…>处**理的任何东西都意味着编译器在当时不为它分配存储空间，**
- 它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。**所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。**

#### 53、**为什么拷贝构造函数必须传引用不能传值？**

- 拷贝构造函数的作用就是用来复制对象的，在使用这个对象的实例来初始化这个对象的一个新的实例。
- 参数传递过程到底发生了什么？ 将地址传递和值传递统一起来，归根结底还是传递的是"值"(地址也是值，只不过通过它可以找到另一个值)！ 
- a 值传递: 对于内置数据类型的传递时，直接赋值拷贝给形参(注意形参是函数内局部变量)； 对于类类型的传递时，需要首先调用该类的拷贝构造函数来初始化形参(局部对象)；如void foo(class_type obj_local){}, 如果调用foo(obj); 首先class_type obj_local(obj) ,这样就定义了局部变量obj_local供函数内部使用
- b 引用传递: 无论对内置类型还是类类型，传递引用或指针最终都是传递的地址值！而地址总是指针类型(属于简单类型), 显然参数传递时，按简单类型的赋值拷贝，而不会有拷贝构造函数的调用(对于类类型). 上述1) 2)回答了为什么拷贝构造函数使用值传递会产生无限递归调用，内存溢出。

**拷贝构造函数用来初始化一个非引用类类型对象，如果用传值的方式进行传参数，那么构造实参需要调用拷贝构造函数，而拷贝构造函数需要传递实参，所以会一直递归。**

#### 54、**静态函数能定义为虚函数吗？常函数呢？说说你的理解**

1. static成员不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义的。
2. 静态与非静态成员函数之间有一个主要的区别，那就是静态成员函数没有this指针。
3. 虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，因为它是类的一个成员，并且vptr指向保存虚函数地址的vtable.对于静态成员函数，它没有this指针，所以无法访问vptr。
4. 这就是为何static函数不能为virtual，虚函数的调用关系：this -> vptr -> vtable ->virtual function。

#### 55、**虚函数的代价是什么？**

- 带有虚函数的类，每一个类会产生一个虚函数表，用来存储指向虚成员函数的指针，增大类；
- 带有虚函数的类的每一个对象，都会有有一个指向虚表的指针，会增加对象的空间大小；
- 不能再是内联的函数，因为内联函数在编译阶段进行替代，而虚函数表示等待，在运行阶段才能确定到底是采用哪种函数，**虚函数不能是内联函数**。

#### 56、**说一说你了解到的移动构造函数？**

- 有时候我们会遇到这样一种情况，我们用对象a初始化对象b后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；
- 拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制；
- C++引入了移动构造函数，专门处理这种，用a初始化b后，就将a析构的情况；
- 与拷贝类似，移动也使用一个对象的值设置另一个对象的值。但是，又与拷贝不同的是，移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。这里未命名的对象就是那些临时变量，甚至都不会有名称。典型的未命名对象就是函数的返回值或者类型转换的对象。使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象。做到这些，就要使用移动构造函数和移动赋值：当使用一个临时变量对象进行构造初始化的时候，调用移动构造函数。类似的，使用未命名的变量的值赋给一个对象时，调用移动赋值操作

#### 57、**什么情况下会合成构造函数？都说一说，你知道的都说一下**

如果一个类没有任何构造函数，但他含有一个成员对象，该成员对象含有默认构造函数，那么编译器就为该类合成一个默认构造函数，因为不合成一个默认构造函数那么该成员对象的构造函数不能调用；

没有任何构造函数的类派生自一个带有默认构造函数的基类，那么需要为该派生类合成一个构造函数，只有这样基类的构造函数才能被调用；

带有虚函数的类，虚函数的引入需要进入虚表，指向虚表的指针，该指针是在构造函数中初始化的，所以没有构造函数的话该指针无法被初始化；

带有一个虚基类的类

还有一点需要注意的是：

并不是任何没有构造函数的类都会合成一个构造函数

编译器合成出来的构造函数并不会显示设定类内的每一个成员变量

#### 58、**那什么时候需要合成拷贝构造函数呢？**

有三种情况会以一个对象的内容作为另一个对象的初值：

对一个对象做显示的初始化操作，X xx = x;

当对象被当做参数交给某个函数时；

当函数传回一个类对象时；

**如果一个类没有拷贝构造函数，但是含有一个类类型的成员变量，该类型含有拷贝构造函数，此时编译器会为该类合成一个拷贝构造函数；**

**如果一个类没有拷贝构造函数，但是该类继承自含有拷贝构造函数的基类，此时编译器会为该类合成一个拷贝构造函数；**

**如果一个类没有拷贝构造函数，但是该类声明或继承了虚函数，此时编译器会为该类合成一个拷贝构造函数；**

**如果一个类没有拷贝构造函数，但是该类含有虚基类，此时编译器会为该类合成一个拷贝构造函数；**

#### 59、**构造函数的执行顺序是什么？**

在派生类构造函数中，所有的虚基类及上一层基类的构造函数调用；

对象的vptr被初始化；

如果有成员初始化列表，将在构造函数体内扩展开来，这必须在vptr被设定之后才做；

执行程序员所提供的代码；

#### 60、**一个类中的全部构造函数的扩展过程是什么？**

记录在成员初始化列表中的数据成员初始化操作会被放在构造函数的函数体内，并与成员的声明顺序为顺序；

如果一个成员并没有出现在成员初始化列表中，但它有一个默认构造函数，那么默认构造函数必须被调用；

如果class有虚表，那么它必须被设定初值；

所有上一层的基类构造函数必须被调用；

所有虚基类的构造函数必须被调用。

#### 61、**哪些函数不能是虚函数？把你知道的都说一说**

构造函数，构造函数初始化对象，派生类必须知道基类函数干了什么，才能进行构造；当有虚函数时，每一个类有一个虚表，每一个对象有一个虚表指针，虚表指针在构造函数中初始化；

内联函数，内***\*联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定\****，所以内联函数不能是虚函数；

静态函数，静态函数不属于对象属于类，**静态成员函数没有this指针**，因此静态函数设置为虚函数没有任何意义。

友元函数，**友元函数不属于类的成员函数，不能被继承**。对于没有继承特性的函数没有虚函数的说法。

普通函数，普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数。

#### 62、**什么是纯虚函数，与虚函数的区别**

虚函数和纯虚函数区别？

虚函数是为了实现动态编联产生的，目的是通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数（使用同一种调用形式，既能调用派生类又能调用基类的同名函数）。虚函数需要在基类中加上virtual修饰符修饰，因为virtual会被隐式继承，所以子类中相同函数都是虚函数。当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数，在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同。

纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化。

纯虚函数首先是虚函数，其次它没有函数体，取而代之的是用“=0”。

既然是虚函数，它的函数指针会被存在虚函数表中，由于纯虚函数并没有具体的函数体，因此它在虚函数表中的值就为0，而具有函数体的虚函数则是函数的具体地址。

一个类中如果有纯虚函数的话，称其为抽象类。抽象类不能用于实例化对象，否则会报错。抽象类一般用于定义一些公有的方法。子类继承抽象类也必须实现其中的纯虚函数才能实例化对象

#### 63、**将字符串“hello world”从开始到打印到屏幕上的全过程?**

用户告诉操作系统执行HelloWorld程序（通过键盘输入等）

2．操作系统：找到helloworld程序的相关信息，检查其类型是否是可执行文件；并通过程序首部信息，确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址。

3．操作系统：创建一个新进程，将HelloWorld可执行文件映射到该进程结构，表示由该进程执行helloworld程序。

4．操作系统：为helloworld程序设置cpu上下文环境，并跳到程序开始处。

5．执行helloworld程序的第一条指令，发生缺页异常

6．操作系统：分配一页物理内存，并将代码从磁盘读入内存，然后继续执行helloworld程序

7．helloword程序执行puts函数（系统调用），在显示器上写一字符串

8．操作系统：找到要将字符串送往的显示设备，通常设备是由一个进程控制的，所以，操作系统将要写的字符串送给该进程

9．操作系统：控制设备的进程告诉设备的窗口系统，它要显示该字符串，窗口系统确定这是一个合法的操作，然后将字符串转换成像素，将像素写入设备的存储映像区

10．视频硬件将像素转换成显示器可接收和一组控制数据信号

11．显示器解释信号，激发液晶屏

12．OK，我们在屏幕上看到了HelloWorld

#### 64、简述一下 C++ 的重载和重写，以及它们的区别

1. 重写

   是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类对象调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。

   示例如下：

```C++
#include<bits/stdc++.h>  
using namespace std;  
class A { 
public:  
    virtual void fun()  {   
        cout << "A";  
    } 
}; 
class B :public A { 
public:  
    virtual void fun()  {   
        cout << "B";  
    } 
}; 

int main(void) {  
    A* a = new B();  
    a->fun();//输出B，A类中的fun在B类中重写 
}
```

1. 重载

   我们在平时写代码中会用到几个函数但是他们的实现功能相同，但是有些细节却不同。例如：交换两个数的值其中包括（int, float,char,double)这些个类型。在C语言中我们是利用不同的函数名来加以区分。这样的代码不美观而且给程序猿也带来了很多的不便。于是在C++中人们提出了用一个函数名定义多个函数，也就是所谓的函数重载。函数重载是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。

```C++
#include<bits/stdc++.h>  
using namespace std;  
class A {  
    void fun() {};  
    void fun(int i) {};  
    void fun(int i, int j) {};     
    void fun1(int i,int j){}; 
};
```

#### 65、说说 C++ 的重载和重写是如何实现的

1. C++利用命名倾轧（name mangling）技术，来改名函数名，区分参数不同的同名函数。命名倾轧是在编译阶段完成的。

   C++定义同名重载函数：

   ```C++
   #include<iostream> 
   using namespace std; 
   int func(int a,double b) {  
   	return ((a)+(b)); 
   } 
   int func(double a,float b) {  
   	return ((a)+(b)); 
   } 
   int func(float a,int b) {  
   	return ((a)+(b)); 
   } 
   int main() {  
       return 0; 
   }
   ```

   ![img](https://uploadfiles.nowcoder.com/images/20220225/4107856_1645788124958/5E57B0F4AE72F40057C2EAA16C4DB902)

   由上图可得，d代表double，f代表float，i代表int，加上参数首字母以区分同名函数。

2. 在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。

   1. 用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数。
   2. 存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。
   3. 多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性。
   4. 重写用虚函数来实现，结合动态绑定。
   5. 纯虚函数是虚函数再加上 = 0。
   6. 抽象类是指包括至少一个纯虚函数的类。

   纯虚函数：virtual void fun()=0。即抽象类必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容。