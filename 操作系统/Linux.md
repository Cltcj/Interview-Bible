### 操作系统 — linux

#### 1、**Linux**中查看进程运行状态的指令、查看内存使用情况的指令、tar 解压文件的参数。

1. **查看进程运行状态的指令**：ps命令。`ps -aux | grep PID`，用来查看某PID进程状态

2. **查看内存使用情况的指令**：free命令。`free -m`，命令查看内存使用情况。

3. **tar**解压文件的参数

- 五个命令中必选一个 
  - ​	-c: 建立压缩档案 
  - -x：解压 
  - -t：查看内容 
  - -r：向压缩归档文件末尾追加文件 
  - -u：更新原压缩包中的文件 
- 这几个参数是可选的 
  - -z：有gzip属性的 
  - -j：有bz2属性的 
  - -Z：有compress属性的 
  - -v：显示所有过程 
  - -O：将文件解开到标准输出 

#### 2、**文件权限怎么修改**

- Linux文件的基本权限就有九个，分别是`owner/group/others`三种身份各有自己的`read/write/execute`权限
- 修改权限指令：`chmod`

#### 3、说说常用的 Linux 命令

1. cd命令：用于切换当前目录

2. ls命令：查看当前文件与目录

3. grep命令：该命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工。

4. cp命令：复制命令

5. mv命令：移动文件或文件夹命令

6. rm命令：删除文件或文件夹命令

7. ps命令：查看进程情况

8. kill命令：向进程发送终止信号

9. tar命令：对文件进行打包，调用gzip或bzip对文件进行压缩或解压

10. cat命令：查看文件内容，与less、more功能相似

11. top命令：可以查看操作系统的信息，如进程、CPU占用率、内存信息等

12. pwd命令：命令用于显示工作目录。

#### 4、说说如何以 root 权限运行某个程序？

`sudo chown root app（文件名） `

`sudo chmod u+s app（文件名）`

#### 5、**说说软链接和硬链接的区别。**

1. **定义不同**

- 软链接又叫符号链接，这个文件包含了另一个文件的路径名。可以是任意文件或目录，可以链接不同文件系统的文件。
- 硬链接就是一个文件的一个或多个文件名。把文件名和计算机文件系统使用的节点号链接起来。因此我们可以用多个文件名与同一个文件进行链接，这些文件名可以在同一目录或不同目录。

2. **限制不同**

- 硬链接只能对已存在的文件进行创建，不能交叉文件系统进行硬链接的创建；
- 软链接可对不存在的文件或目录创建软链接；可交叉文件系统；

3. **创建方式不同**

- <u>硬链接不能对目录进行创建，只可对文件创建</u>；
- 软链接可对文件或目录创建；

4. **影响不同**

- 删除一个硬链接文件并不影响其他有相同 inode 号的文件。
- 删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。

#### 6、**说说静态库和动态库怎么制作及如何使用，区别是什么。**

**静态库的制作：**

```c++
gcc hello.c -c //这样就生成hello.o目标文件 
ar rcs libhello.a hello.o//生成libhello.a静态库
```

**静态库的使用：**

```C++
gcc main.c -lhello -o staticLibrary//main.c和hello静态库链接，生成staticLibrary执行 文件
/* main.c：是指main主函数 
-lhello：是我们生成的.a 文件砍头去尾（lib不要 .a也不要）前面加-l 
-L：是指告诉gcc编译器先从-L指定的路径去找静态库，默认是从/usr/lib/ 或者 /usr/local/lib/ 去找。 
./：是指当前路径的意思
staticLibrary：是最后想生成的文件名（这里可随意起名字）
*/
```

**动态库的制作：**

```
gcc -shared -fpic hello.c -o libhello.so 
-shared 指定生成动态库 
-fpic ：fPIC选项作用于编译阶段，在生成目标文件时就得使用该选项，以生成位置无关的代码。
```

**动态库的使用：**

```C++
gcc main.c -lhello -L ./ -o dynamicDepot 
/* main.c：是指main主函数 
-lhello：是我们生成的.so 文件砍头去尾（lib不要 .so也不要）前面加-l 
-L：是指告诉gcc编译器先从-L指定的路径去找静态库，默认是从/usr/lib/ 或者 /usr/local/lib/ 去找。 
./：是指当前路径的意思 
dynamicDepot：是最后想生成的文件名（这里可随意起名字） */
```

**区别：**

1. 静态库代码装载的速度快，执行速度略比动态库快。

2. 动态库更加节省内存，可执行文件体积比静态库小很多。

3. 静态库是在编译时加载，动态库是在运行时加载。

4. 生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。

#### 7、简述 GDB 常见的调试命令，什么是条件断点，多进程下如何调试。

**GDB****调试**：gdb调试的是可执行文件，在gcc编译时加入 -g ，告诉gcc在编译时加入调试信息，这样gdb才能调试这个被编译的文件 gcc -g tesst.c -o test

**GDB**命令格式：

1. quit：退出gdb，结束调试

2. list：查看程序源代码

​	`list 5，10：显示5到10行的代码`

​	`list test.c:5, 10: 显示源文件5到10行的代码，在调试多个文件时使用`

​	`list get_sum: 显示get_sum函数周围的代码`

​	`list test,c get_sum: 显示源文件get_sum函数周围的代码，在调试多个文件时使用`

3. reverse-search：字符串用来从当前行向前查找第一个匹配的字符串

4. run：程序开始执行

5. help list/all：查看帮助信息

6. break：设置断点

​	`break 7：在第七行设置断点`

​	`break get_sum：以函数名设置断点`

​	`break 行号或者函数名 if 条件：以条件表达式设置断点`

7. watch 条件表达式：条件表达式发生改变时程序就会停下来

8. next：继续执行下一条语句 ，会把函数当作一条语句执行
9. step：继续执行下一条语句，会跟踪进入函数，一次一条的执行函数内的代码

**条件断点：**break if 条件 以条件表达式设置断点

**多进程下如何调试：**用`set follow-fork-mode child` 调试子进程或者`set follow-fork-mode parent` 调试父进程

#### 8、**说说什么是大端小端，如何判断大端小端？**

**小端模式**：**低**的有效字节存储在**低的**存储器地址。小端一般为主机字节序；常用的X86结构是小端模式。很多的ARM，DSP都为小端模式。

**大端模式**：**高**的有效字节存储在**低的**存储器地址。大端为网络字节序；KEIL C51则为大端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。

如何判断：我们可以根据**联合体**来判断系统是大端还是小端。因为联合体变量总是从**低地址**存储。















#### 39、**说说什么是死锁，产生的条件，如何解决？**

1. **死锁**: <u>是指多个进程在执行过程中，因争夺资源而造成了互相等待。此时系统产生了死锁。</u>比如两只羊过独木桥，若两只羊互不相让，争着过桥，就产生死锁。

2. **产生的条件**：死锁发生有**四个必要条件**： 
   - **互斥条件**：进程对所分配到的资源不允许其他进程访问，若其他进程访问，只能等待，直到进程使用完成后释放该资源；
   - **请求保持条件**：进程获得一定资源后，又对其他资源发出请求，但该资源被其他进程占有，此时请求阻塞，而且该进程不会释放自己已经占有的资源；
   - **不可剥夺条件**：进程已获得的资源，只能自己释放，不可剥夺；
   - **环路等待条件**：若干进程之间形成一种头尾相接的循环等待资源关系。

3. **如何解决**： 
   1. 资源一次性分配，从而解决请求保持的问题
   2. 可剥夺资源：当进程新的资源未得到满足时，释放已有的资源；
   3. 资源有序分配：资源按序号递增，进程请求按递增请求，释放则相反





