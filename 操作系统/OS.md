#### 1、**说说进程、线程、协程是什么，区别是什么？**

1. **进程**：程序是指令、数据及其组织形式的描述，而进程则是程序的运行实例，包括程序计数器、寄存器和变量的当前值。

2. **线程**：微进程，一个进程里更小粒度的执行单元。一个进程里包含多个线程并发执行任务。

3. **协程**：协程是微线程，在子程序内部执行，可在子程序内部中断，转而执行别的子程序，在适当的时候再返回来接着执行。

**区别**：

- ① 进程是资源分配和拥有的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序。

- ② 线程是程序执行的基本单位，是轻量级的进程，每个进程都有唯一的主线程，且只有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束，协程是用户态的轻量级线程，线程内部调度的基本单位

1. **线程与进程的区别**： 
   - 一个线程从属于一个进程；一个进程可以包含多个线程。
   - 一个线程挂掉，对应的进程挂掉；一个进程挂掉，不会影响其他进程。
   - 进程是系统资源调度的最小单位；线程CPU调度的最小单位。
   - 进程系统开销显著大于线程开销；线程需要的系统资源更少。
   - 进程在执行时拥有独立的内存单元，多个线程共享进程的内存，如代码段、数据段、扩展段；但每个线程拥有自己的栈段和寄存器组。
   - 进程切换时需要刷新TLB并获取新的地址空间，然后切换硬件上下文和内核栈，线程切换时只需要切换硬件上下文和内核栈。
   - 通信方式不一样。
   - 进程适应于多核、多机分布；线程适用于多核
2. **线程与协程的区别：**
   - 协程执行效率极高。协程直接操作栈基本没有内核切换的开销，所以上下文的切换非常快，切换开销比线程更小。
   - 协程不需要多线程的锁机制，因为多个协程从属于一个线程，不存在同时写变量冲突，效率比线程高。
   - 一个线程可以有多个协程。

#### 2、**协程是轻量级线程，轻量级表现在哪里？**

1. **协程调用跟切换比线程效率高**：协程执行效率极高。<u>协程不需要多线程的锁机制</u>，可以不加锁的访问全局变量，所以上下文的切换非常快。

2. **协程占用内存少**：执行协程只需要极少的栈内存（大概是4～5KB），而默认情况下，线程栈的大小为1MB。 

3. **切换开销更少**：协程直接操作栈基本没有内核切换的开销，所以切换开销比线程少。

#### 3、**有了进程，为什么还要有线程？**

1. **原因**

   - 进程在早期的多任务操作系统中是基本的**执行单元**。每次进程切换，都要先保存进程资源然后再恢复，这称为<u>上下文切换</u>。**但是进程频繁切换将引起额外开销，从而严重影响系统的性能。**为了减少进程切换的开销，人们把两个任务放到一个进程中，每个任务用一个更小**粒度**的执行单元来实现并发执行，这就是**线程**。 

2. **线程与进程对比**

   - **进程间的信息难以共享。**由于除去只读代码段外，父子进程并未共享内存，因此必须采用一些进程间通信方式，在进程间进行信息交换。但**多个线程共享**进程的内存，如代码段、数据段、扩展段，线程间进行信息交换十分方便。

   - 调用 fork() 来创建进程的代价相对较高，即便利用写时复制技术，仍然需要复制诸如内存页表和文件描述符表之类的多种进程属性，这意味着 fork() 调用在时间上的开销依然不菲。**但创建线程比创建进程通常要快** **10** **倍甚至更多。**线程间是共享虚拟地址空间的，无需采用写时复制来复制内存，也无需复制页表。

#### 4、线程和进程的比较

- ① 线程启动速度快、轻量级
- ② 线程的系统开销小
- ③ 线程使用有一定难度，需要处理数据一致性问题
- ④ 同一线程共享的有堆、全局变量、静态变量、指针、引用、文件等，而独自占有栈。

#### 5、线程和进程的区别？

- 线程是调度的基本单位（PC，状态码，通用寄存器，线程栈及栈指针），进程是拥有资源的基本单位（打开文件，堆，静态区，代码段）
- 一个进程内多个线程可以并发；多个进程可以并发。
- 线程不拥有系统资源，但一个进程的多个线程可以共享隶属进程的资源；进程是拥有资源的独立单位。
- 线程开销小，线程创建销毁只需要处理PC值，状态码，通用寄存器，线程栈和栈指针即可，进程创建和销毁需要重新分配及销毁task_struct结构。 

#### 6、**一个线程占多大内存？**

- 一个linux的线程大概占8M内存。
- linux的栈是通过缺页来分配内存的，不是所有栈地址空间都分配了内存。因此，8M是最大消耗，实际的内存消耗只会略大于实际需要的内存(内部损耗，每个在4k以内)。

#### **7、一个进程可以创建多少线程，和什么有关？**

- 理论上，一个进程可用的虚拟空间是2G，默认情况下，线程栈的大小是1MB，所以理论上只能创建2048个线程，如果创建多于2048个进程的话，必须修改编译器的设置。
- 因此一个进程可以创建的线程数由可用虚拟空间和线程的栈的大小共同决定，只要虚拟空间足够，新线程的建立就会成功。如需要创建大于2k以上的线程，减小你线程栈的大小就可以实现了，虽然一般情况下，不需要创建那么多的线程，线程太多会导致大量的时间浪费在线程切换上，给程序运行效率带来负面影响。

#### 8、**进程状态切换你知道多少？**

- 只有就绪态和运行态之间可以互相切换，其它都是单向切换。当就绪态的进程通过调度算法从而获得CPU时间片，就会转换为运行态，当处于运行态的进程如过时间片用完了就会切换到就绪态。
- 阻塞态是缺少需要的资源从而从运行态转换过来的，但这种资源不包括CPU时间片。

**相互转换如图**：

![image-20220812132026393](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220812132026393.png)

#### 9、**说说进程有多少种状态？**

进程有五种状态：**创建、就绪、执行、阻塞、终止**。一个进程创建后，被放入队列处于就绪状态，等待操作系统调度执行，执行过程中可能切换到阻塞状态（并发），任务完成后，进程销毁终止。

**创建状态**

- 一个应用程序从系统上启动，首先就是进入**创建状态**，需要获取系统资源创建进程管理块（PCB：Process Control Block）完成资源分配。

**就绪状态**

- 在**创建状态**完成之后，进程已经准备好，处于**就绪状态**，但是还未获得处理器资源，无法运行。

**运行状态**

- 获取处理器资源，被系统调度，**当具有时间片**开始进入**运行状态**。如果进程的时间片用完了就进入**就绪状态**。

**阻塞状态**

- 在**运行状态**期间，如果进行了阻塞的操作，如耗时的I/O操作，此时进程暂时无法操作就进入到了**阻塞状态**，在这些操作完成后就进入**就绪状态**。等待再次获取处理器资源，被系统调度，**当具有时间片**就进入**运行状态**。

**终止状态**

- 进程结束或者被系统终止，进入**终止状态**

#### 10、**请你说说线程有哪些状态，相互之间怎么转换？**

类似进程，有以下五种状态：

1. **新建状态(New)**

2. **就绪状态(Runnable)**

3. **运行状态(Running)**

4. **阻塞状态(Blocked)**

5. **终止状态(Dead)**

**转换方式如下**：

**创建状态**

- 一个应用程序从系统上启动，首先就是进入**创建状态**，获取系统资源。

**就绪状态**

- 在**创建状态**完成之后，线程已经准备好，处于**就绪状态**，但是还未获得处理器资源，无法运行。

**运行状态**

- 获取处理器资源，被系统调度，当具有时间片开始进入**运行状态**。如果线程的时间片用完了就进入**就绪状态**。

**阻塞状态**

- 在**运行状态**期间，如果进行了阻塞的操作，如耗时的I/O操作，此时线程暂时无法操作就进入到了**阻塞状态**，在这些操作完成后就进入**就绪状态**。等待再次获取处理器资源，被系统调度，当具有时间片就进入**运行状态**。

**终止状态**

- 线程结束或者被系统终止，进入**终止状态**

相互转换如图：

![image-20220812132026393](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220812132026393.png)

#### 11、**进程、线程的中断切换的过程是怎样的？**

上下文切换指的是内核（操作系统的核心）在CPU上对进程或者线程进行切换。

1. **进程上下文切换**

   1. 保护被中断进程的处理器现场信息

   2. 修改被中断进程的进程控制块有关信息，如进程状态等

   3. 把被中断进程的进程控制块加入有关队列

   4. 选择下一个占有处理器运行的进程

   5. 根据被选中进程设置操作系统用到的地址转换和存储保护信息

      - **切换页目录以使用新的地址空间**

      - **切换内核栈和硬件上下文（包括分配的内存，数据段，堆栈段等）**

   6. 根据被选中进程恢复处理器现场

2. **线程上下文切换**
   1. 保护被中断线程的处理器现场信息
   2. 修改被中断线程的线程控制块有关信息，如线程状态等
   3. 把被中断线程的线程控制块加入有关队列
   4. 选择下一个占有处理器运行的线程
   5. 根据被选中线程设置操作系统用到的存储保护信息
      - **切换内核栈和硬件上下文（切换堆栈，以及各寄存器）**
   6. 根据被选中线程恢复处理器现场

#### 12、**说说进程通信的方式有哪些？**

进程间通信主要包括**管道**、**系统** **IPC**（包括消息队列、信号量、信号、共享内存）、**套接字** **socket**。 

1. **管道**：包括无名管道 **pipe** 和命名管道 **FIFO**，无名管道半双工，只能用于具有亲缘关系的进程直接的通信（父子进程或者兄弟进程），可以看作一种特殊的文件；命名管道可以允许无亲缘关系进程间的通信。

2. **系统** **IPC**
   - **消息队列**：消息的链接表，放在内核中。消息队列独立于发送与接收进程，进程终止时，消息队列及其内容并不会被删除；消息队列可以实现消息的随机查询，可以按照消息的类型读取。
   - **信号量** **semaphore**：是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步。**
   - **信号**：用于通知接收进程某个事件的发生。
   - **共享内存**：使多个进程访问同一块内存空间。

3. **套接字** **socket**：用于不同主机直接的通信。

#### 13、**说说进程同步的方式？**

1. **信号量** **semaphore**：是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步。P操作(递减操作)可以用于阻塞一个进程，V操作(增加操作)可以用于解除阻塞一个进程。
2. **管道**：一个进程通过调用管程的一个过程进入管程。在任何时候，只能有一个进程在管程中执行，调用管程的任何其他进程都被阻塞，以等待管程可用。
3. **消息队列**：消息的链接表，放在内核中。消息队列独立于发送与接收进程，进程终止时，消息队列及其内容并不会被删除；消息队列可以实现消息的随机查询，可以按照消息的类型读取。

#### **13、进程同步的四种方法？**

**①** **临界区**

- 对临界资源进行访问的那段代码称为临界区。
- 为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。

**②** **同步和互斥**

- 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系
- 互斥：多个进程在同一时刻只有一个进程能进入临界区。

**③** **信号量**

- 信号量是一个整型变量，可以对其执行P、V操作。

- P：如果信号量大于0，执行-1操作，如果信号量等于0，进程睡眠，等待信号量大于0
- V：对信号量执行+1操作，唤醒睡眠的进程让其完成down操作。
- P、V操作需要被设计成原语，不可分割，通常做法是在执行这些操作的时候屏蔽中断。

- 如果信号量的取值只能为0或1，那么就成为互斥量（Mutex），0表示临界区已经加锁，1表示临界区解锁。

**④ 管程**

- 管程特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。管程引入了条件变量以及相关操作：wait()和signal()来实现同步

#### 14、**说说线程间通信的方式有哪些？**

线程间的通信方式包括**临界区、互斥量、信号量、条件变量、读写锁**： 

1. 临界区：每个线程中访问临界资源的那段代码称为临界区（Critical Section）（临界资源是一次仅允许一个线程使用的共享资源）。每次只准许一个线程进入临界区，进入后不允许其他线程进入。不论是硬件临界资源，还是软件临界资源，多个线程必须互斥地对它进行访问。
2. 互斥量：采用互斥对象机制，只有拥有互斥对象的线程才可以访问。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。
3. 信号量：计数器，允许多个线程同时访问同一个资源。
4. 条件变量：通过条件变量通知操作的方式来保持多线程同步。
5. 读写锁：读写锁与互斥量类似。但互斥量要么是锁住状态，要么就是不加锁状态。读写锁一次只允许一个线程写，但允许一次多个线程读，这样效率就比互斥锁要高。

#### 15、**说说线程同步方式有哪些？**

线程间的同步方式包括**互斥锁、信号量、条件变量、读写锁**： 

1. **互斥锁**：采用互斥对象机制，只有拥有互斥对象的线程才可以访问。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。
2. **信号量**：计数器，允许多个线程同时访问同一个资源。
3. **条件变量**：通过条件变量通知操作的方式来保持多线程同步。
4. **读写锁**：读写锁与互斥量类似。但互斥量要么是锁住状态，要么就是不加锁状态。读写锁一次只允许一个线程写，但允许一次多个线程读，这样效率就比互斥锁要高。

#### 16、**进程通信中的管道实现原理是什么？**

- 操作系统在内核中开辟一块**缓冲区**（称为**管道**）用于通信。**管道**是一种两个进程间进行**单向通信**的机制。因为这种单向性，管道又称为半双工管道，所以其使用是有一定的局限性的。半双工是指数据只能由一个进程流向另一个进程（一个管道负责读，一个管道负责写）；如果是全双工通信，需要建立两个管道。管道分为无名管道和命名管道，无名管道只能用于具有亲缘关系的进程直接的通信（父子进程或者兄弟进程），可以看作一种特殊的文件，**管道本质是一种文件**；命名管道可以允许无亲缘关系进程间的通信。

- 管道原型如下：

```c++
＃include <unistd.h> 
int pipe(int fd[2]);
```

- pipe()函数创建的管道处于一个进程中间，因此一个进程在由 pipe()创建管道后，一般再使用fork() 建立一个子进程，然后通过管道实现父子进程间的通信。管道两端可分别用描述字fd[0]以及fd[1]来描述。注意管道的两端的任务是固定的，即一端只能用于读，由描述字fd[0]表示，称其为管道读端；另 一端则只能用于写，由描述字fd[1]来表示，称其为管道写端。如果试图从管道写端读取数据，或者向管道读端写入数据都将发生错误。一般文件的 I/O 函数都可以用于管道，如close()、read()、write()等。

**具体步骤**如下：

1. 父进程调用pipe开辟管道,得到两个文件描述符指向管道的两端。
2. 父进程调用fork创建子进程,那么子进程也有两个文件描述符指向同一管道。
3. 父进程关闭管道读端,子进程关闭管道写端。父进程可以往管道里写,子进程可以从管道里读,管道是用环形队列实现的,数据从写端流入从读端流出,这样就实现了进程间通信。

#### **17、终端退出，终端运行的进程会怎样**

- 终端在退出时会发送SIGHUP给对应的bash进程，bash进程收到这个信号后首先将它发给session下面的进程，如果程序没有对SIGHUP信号做特殊处理，那么进程就会随着终端关闭而退出

#### **18、如何让进程后台运行**

1. 命令后面加上&即可，实际上，这样是将命令放入到一个作业队列中了
2. ctrl + z 挂起进程，使用jobs查看序号，在使用bg %序号后台运行进程
3. nohup + &，将标准输出和标准错误缺省会被重定向到 nohup.out 文件中，忽略所有挂断（SIGHUP）信号
4. 运行指令前面 + setsid，使其父进变成init进程，不受HUP信号的影响
5. 将 命令+ &放在()括号中，也可以是进程不受HUP信号的影响

#### **19、父进程、子进程、进程组、作业和会话**

**父进程**

- 已创建一个或多个子进程的进程

**子进程**

- 由fork创建的新进程被称为子进程（child process）。该函数被调用一次，但返回两次。两次返回的区别是子进程的返回值是0，而父进程的返回值则是新进程（子进程）的进程 id。

**子进程从父进程继承的有：**

1. 进程的资格(真实(real)/有效(effective)/已保存(saved)用户号(UIDs)和组号(GIDs))
2. 环境(environment)
3. 堆栈
4. 内存
5. 进程组号

**独有：**

1. 进程号；
2. 不同的父进程号(译者注：即子进程的父进程号与父进程的父进程号不同， 父进程号可由getppid函数得到)；
3. 资源使用(resource utilizations)设定为0

**进程组**

- shell分前后台来控制的不是进程而是作业（job）或者进程组（Process Group）。
- 一个前台作业可以由多个进程组成，一个后台也可以由多个进程组成，shell可以运行一个前台作业和任意多个后台作业，这称为作业控制

**为什么只能运行一个前台作业？**

- 当我们在前台新起了一个作业，shell就被提到了后台，因此shell就没有办法再继续接受我们的指令并且解析运行了。 但是如果前台进程退出了，shell就会有被提到前台来，就可以继续接受我们的命令并且解析运行。

- 作业与进程组的区别：如果作业中的某个进程有创建了子进程，则该子进程是不属于该作业的。 一旦作业运行结束，shell就把自己提到前台（子进程还存在，但是子进程不属于作业），如果原来的前台进程还存在（这个子进程还没有终止），他将自动变为后台进程组

**会话**

- **会话（Session）是一个或多个进程组的集合。**一个会话可以有一个控制终端。在xshell或者WinSCP中打开一个窗口就是新建一个会话。

#### **20、进程终止的几种方式**

1. main函数的自然返回，return 
2. 调用exit函数，属于c的函数库 
3. 调用_exit函数，属于系统调用 
4. 调用abort函数，异常程序终止，同时发送SIGABRT信号给调用进程。 
5. 接受能导致进程终止的信号：ctrl+c 、SIGINT(SIGINT中断进程)

#### 21、**互斥量能不能在进程中使用？**

- **能**。不同的进程之间，存在资源竞争或并发使用的问题，所以需要**互斥量**。
- 进程中也需要**互斥量**，因为一个进程中可以包含多个线程，线程与线程之间需要通过互斥的手段进行同步，避免导致共享数据修改引起冲突。可以使用**互斥锁**，属于互斥量的一种。

#### **22、Linux下同步机制？**

- POSIX信号量：可用于进程同步，也可用于线程同步。
- POSIX互斥锁 + 条件变量：只能用于线程同步。

#### 23、**简述互斥锁的机制，互斥锁与读写的区别？**

1. **互斥锁机制**：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。

2. **互斥锁和读写锁**： 
   - 读写锁区分读者和写者，而互斥锁不区分
   - 互斥锁同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象。

#### 24、**说说什么是信号量，有什么作用？**

1. **概念**：信号量本质上是一个计数器，用于多进程对共享数据对象的读取，它主要是用来保护共享资源（信号量也属于临界资源），使得资源在一个时刻只有一个进程独享。
2. **原理**：由于信号量只能进行两种操作等待和发送信号，即P(sv)和V(sv)，具体的行为如下：

   1. P(sv)操作：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行（信号量的值为正，进程获得该资源的使用权，进程将信号量减1，表示它使用了一个资源单位）。

   2. V(sv)操作：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1（若此时信号量的值为0，则进程进入挂起状态，直到信号量的值大于0，若进程被唤醒则返回至第一步）。

3. **作用**：用于多进程对共享数据对象的读取，它主要是用来保护共享资源（信号量也属于临界资源），使得资源在一个时刻只有一个进程独享。

#### **25、**介绍一下几种典型的锁？

**读写锁**

- 多个读者可以同时进行读（读读共享）
- 写者必须互斥（只允许一个写着写，也不能读者写者同时进行）
- 写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）

**互斥锁**

- 一次只能一个线程拥有互斥锁，其它线程只有等待
- 互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态知直到锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发生改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发送改变时

**条件变量**

- 互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。总的来说互斥锁是线程间互斥的机制，条件变量则是同步机制。

**自旋锁**

- 如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。如果别的线程长时期占有锁，那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。

#### **26、你知道哪几种线程锁（POSIX）？**

**互斥锁（mutex）**

- 互斥锁属于sleep-waiting类型的锁。

**条件变量(cond)**

**自旋锁(spin)**

自旋锁属于busy-waiting类型的锁，虽然它的效率比互斥锁高，但是它也有些不足之处：

- ① 自旋锁一直占用CPU，在未获得锁的情况下，一直进行自旋，所以占用着CPU，如果不能在很短的时间内获得锁，无疑会使CPU效率降低。
- ② 在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁。
- ③ 自旋锁只有在内核可抢占式或SMP的情况下才真正需要，在单CPU且不可抢占式的内核下，自旋锁的操作为空操作。自旋锁适用于锁使用者保持锁时间比较短的情况下。

#### 27、**简述自旋锁和互斥锁的使用场景**

1. **互斥锁**用于临界区持锁时间比较长的操作，比如下面这些情况都可以考虑

   - 临界区有IO操作

   - 临界区代码复杂或者循环量大
   - 临界区竞争非常激烈
   - 单核处理器

2. **自旋锁就**主要用在临界区持锁时间非常短且CPU资源不紧张的情况下。

#### 28、**单核机器上写多线程程序，是否要考虑加锁，为什么？**

- 在单核机器上写多线程程序，仍然需要线程锁。
- **原因**：因为线程锁通常用来实现线程的同步和通信。在单核机器上的多线程程序，仍然存在线程同步的问题。因为在抢占式操作系统中，通常为每个线程分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。如果这两个线程共享某些数据，**不使用线程锁的前提下，可能会导致共享数据修改引起冲突。**

#### 29、**说说多线程和多进程的不同？**

1. 一个线程从属于一个进程；一个进程可以包含多个线程。
2. 一个线程挂掉，对应的进程挂掉，多线程也挂掉；一个进程挂掉，不会影响其他进程，多进程稳定。
3. 进程系统开销显著大于线程开销；线程需要的系统资源更少。
4. 多个进程在执行时拥有各自独立的内存单元，多个线程共享进程的内存，如代码段、数据段、扩展段；但每个线程拥有自己的栈段和寄存器组。
5. 多进程切换时需要刷新TLB并获取新的地址空间，然后切换硬件上下文和内核栈；多线程切换时只需要切换硬件上下文和内核栈。
6. 通信方式不一样。
7. 多进程适应于多核、多机分布；多线程适用于多核

#### **29、多进程和多线程的区别是什么？换句话说，什么时候该用多线程，什么时候该用多进程？**

1. 频繁修改：需要频繁创建和销毁的优先使用多线程

   计算量：需要大量计算的优先使用多线程 因为需要消耗大量CPU资源且切换频繁，所以多线程好一点

2. 相关性：任务间相关性比较强的用多线程，相关性比较弱的用多进程。**因为线程之间的数据共享和同步比较简单。**

3. 多分布：可能要扩展到多机分布的用多进程，多核分布的用多线程。

#### 30、多线程和单线程有什么区别，多线程编程要注意什么，多线程加锁需要注意什么？

1. **区别**：
   - 多线程从属于一个进程，单线程也从属于一个进程；一个线程挂掉都会导致从属的进程挂掉。
   - 一个进程里有多个线程，可以并发执行多个任务；一个进程里只有一个线程，就只能执行一个任务。
   - 多线程并发执行多任务，需要切换内核栈与硬件上下文，有切换的开销；单线程不需要切换，没有切换的开销。
   - 多线程并发执行多任务，需要考虑同步的问题；单线程不需要考虑同步的问题。

2. 多线程编程需要考虑**同步**的问题。线程间的同步方式包括**互斥锁、信号量、条件变量、读写锁**。 

3. 多线程加锁，主要需要注意**死锁**的问题。破坏死锁的必要条件从而避免死锁

#### 31、**进程和线程相比，为什么慢？**

1. 进程系统开销显著大于线程开销；线程需要的系统资源更少。

2. 进程切换开销比线程大。多进程切换时需要刷新TLB并获取新的地址空间，然后切换硬件上下文和内核栈；多线程切换时只需要切换硬件上下文和内核栈。

3. 进程通信比线程通信开销大。进程通信需要借助管道、队列、共享内存，需要额外申请空间，通信繁琐；而线程共享进程的内存，如代码段、数据段、扩展段，通信快捷简单，同步开销更小。

#### 32、系统并发和并行，分得清吗？

- 并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。
- 并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。
- 操作系统通过引入进程和线程，使得程序能够并发运行。

#### 33、**请你说说并发和并行**

1. **并发**：对于单个CPU，在一个时刻只有一个进程在运行，但是线程的切换时间则减少到纳秒数量级，多个任务不停来回快速切换。
2. **并行**：对于多个CPU，多个进程同时运行。
3. **区别**。通俗来讲，它们虽然都说是"多个进程同时运行"，但是它们的"同时"不是一个概念。并行的"同时"是同一时刻可以多个任务在运行(处于running)，并发的"同时"是经过不同线程快速切换，使得看上去多个任务同时都在运行的现象。

#### 34、**请你说说什么是孤儿进程，什么是僵尸进程，如何解决僵尸进**程

1. **孤儿进程**：是指一个父进程退出后，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被init进程（进程号为1）所收养，并且由init进程对它们完整状态收集工作。

2. **僵尸进程**：是指一个进程使用fork函数创建子进程，如果子进程退出，而父进程并没有调用wait()或者waitpid()系统调用取得子进程的终止状态，那么子进程的进程描述符仍然保存在系统中，占用系统资源，这种进程称为僵尸进程。

3. **如何解决僵尸进程**： 
   1. 一般，为了防止产生僵尸进程，在fork子进程之后我们都要及时使用 **wait** 系统调用**；同时，当子进程退出的时候，内核都会给父进程一个SIGCHLD信号，所以我们可以建立一个捕获SIGCHLD信号的信号处理函数，在函数体中调用wait（或waitpid），就可以清理退出的子进程以达到防止僵尸进程的目的。**
   2. 使用kill命令：
      1. 打开终端并输入下面命令: `ps aux | grep Z` 	
      2. 会列出进程表中所有僵尸进程的详细内容。然后输入命令：`kill -s SIGCHLD pid(父进程pid)`

#### 35、**请你说说什么是守护进程，如何实现？**

1. **守护进程**：守护进程是运行在后台的一种生存期长的特殊进程。它独立于控制终端，处理一些系统级别任务。

2. **如何实现**： 
   1. 创建子进程，终止父进程。方法是调用fork() 产生一个子进程，然后使父进程退出。
   2. 调用setsid() 创建一个新会话。
   3. 将当前目录更改为根目录。使用fork() 创建的子进程也继承了父进程的当前工作目录。
   4. 重设文件权限掩码。文件权限掩码是指屏蔽掉文件权限中的对应位。
   5. 关闭不再需要的文件描述符。子进程从父进程继承打开的文件描述符。

```c++
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
#include <fcntl.h> 
#include <unistd.h> 
#include <sys/wait.h> 
#include <sys/types.h> 
#include <sys/stat.h> 
#define MAXFILE 65535 
int main(){ 
    //第一步:创建进程 
    int pid = fork(); 
    if (pid > 0) exit(0);//结束父进程 
    else if (pid < 0){ 
        printf("fork error!\n"); 
        exit(1);//fork失败，退出 
    }
    //第二步:子进程成为新的会话组长和进程组长,并与控制终端分离 
    setsid(); 
    //第三步:改变工作目录到 
    chdir("/"); //第四步:重设文件创建掩模 
    umask(0); //第五步:关闭打开的文件描述符 
    for (int i=0; i<MAXFILE; ++i){
        close(i); 
        sleep(2); 
    }
    return 0; 
}
```

#### 36、**说说进程调度算法有哪些？**

1. **先来先服务调度算法**
   - 先来先服务调度算法：每次调度都是从后备作业（进程）队列中选择一个或多个最先进入该队列的作业（进程），将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。


2. **短作业(进程)优先调度算法**
   - 短作业(进程)优先调度算法：短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业（进程），将它们调入内存运行。


3. **最短剩余时间优先**
   - 最短剩余时间优先：最短作业优先的抢占式版本，按照剩余运行时间的顺序进行调度，当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。
   - 如果新进程需要的时间更少，则挂起当前进程，运行新的进程，否则新的进程等待。


4. **时间片轮转法**
   -  时间片轮转法：每次调度时，把CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几ms 到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。

5. **优先级调度**
   - 为每个进程分配一个优先级，按优先级进行调度。
   - 为了防止低优先级的进程永远得不到调度，可以随着时间的推移增加等待进程的优先级。
6. **多级反馈队列调度算法**
   - 一个进程需要执行100个时间片，如果采用时间片轮转，就需要100次交换。多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如1，2，4，8...进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要被交换7次，每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。它是**时间片轮转法**和**优先级调度**的结合。


**区别：**

- 非抢占式（Nonpreemptive）：让进程运行直到结束或阻塞的调度方式，容易实现，适合专用系统，不适合通用系统。
- 抢占式（Preemptive）：允许将逻辑上可继续运行的在运行过程暂停的调度方式可防止单一进程长时间独占，CPU系统开销大（降低途径：硬件实现进程切换，或扩充主存以贮存大部分程序）

#### 37、怎么回收线程？有几种方法？

**①** **等待线程结束：**int pthread_join(pthread_t tid, void retval);

主线程调用，等待子线程退出并回收其资源，类似于进程中wait/waitpid回收僵尸进程，调用pthread_join的线程会被阻塞。

tid：创建线程时通过指针得到tid值。

retval：指向返回值的指针。

**②** ***\*结束线程：\****pthread_exit(void *retval);

子线程执行，用来结束当前线程并通过retval传递返回值，该返回值可通过pthread_join获得。

**③** ***\*分离线程：\****int pthread_detach(pthread_t tid);

主线程、子线程均可调用。主线程中pthread_detach(tid)，子线程中pthread_detach(pthread_self())，调用后和主线程分离，子线程结束时自己立即回收资源。

#### 38、**请你说说**Linux**的**fork的作用

fork()函数，其原型如下：

```C++
#include <unistd.h> 
pid_t fork(void);
```

fork()函数不需要参数，返回值是一个进程标识符PID。返回值有以下三种情况：

- 对于父进程，fork()函数返回新创建的子进程的PID。 
- 对于子进程，fork()函数调用成功会返回0。 
- 如果创建出错，fork()函数返回-1。

#### 39、**简述**mmap**的原理和使用场景**

- **原理**：**mmap**是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read, write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。如下图：

![image-20220812134525731](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220812134525731.png)

**使用场景**：

1. 对同一块区域频繁读写操作；

2. 可用于实现用户空间和内核空间的高效交互

3. 可提供进程间共享内存及相互通信

4. 可实现高效的大规模数据传输。

