### 数据库高频面试模块（1）— 索引、存储引擎

### 一、索引

#### 1、**索引的基本原理，索引是什么？**

- 索引就是把无序的数据变成有序的查询，具体就是用来快速地寻找那些具有特定值的记录。

- 索引是一个单独的、存储在磁盘上的数据库结构，包含着对数据表里所有记录的引用指针。使用索引可以快速找出在某个或多个列中有一特定值的行，所有MySQL列类型都可以被索引，对相关列使用索引是提高查询操作速度的最佳途径。
- **索引是在存储引擎中实现的**，因此，每种存储引擎的索引都不一定完全相同，并且每种存储引擎也不一定支持所有索引类型。MySQL中索引的存储类型有两种，即BTREE和HASH，具体和表的存储引擎相关。MyISAM和InnoDB存储引擎只支持BTREE索引；MEMORY/HEAP存储引擎可以支持HASH和BTREE索引

#### 2、为什么使用索引？

① 通过创建唯一性索引，可以保证数据表中每一行数据的唯一性。

② **可以大大加快数据的检索速度，这也是创建索引的最主要原因**

③ 帮助服务器避免排序和临时表

④ 将随机IO变成顺序IO

⑤ 可以加速表和表之间的连接，特别是实现数据的参考完整性方面特别有意义

#### 3、索引设计的原则

查询更快，占用空间更小

1. 适合索引的列：出现where或连接子句的列。
2. 基数较小的表没必要建索引，因为索引效果差。
3. 使用短索引，如果对长字符串进行索引，应指定一个前缀长度，这样能够节省大量索引空间，如果索引词超过索引前缀长度，则使用索引排除比匹配的行，然后检查其余行是否可能匹配。
4. 不要过度索引。
5. 定义有外键的数据列一定要建立索引
6. 更新频繁字段不适合建立索引
7. 若是不能有效区分数据的列不适合做索引列
8. 尽量的扩展索引
9. 对于那些查询很少涉及的列，重复值比较多的列不要建立索引。
10. 对于定义为text、image和bit的数据类型的列不要建立索引。 

#### 4、**MySQL中有四种索引类型，可以简单说说吗？**

**FULLTEXT：即为全文索引**，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过<u>目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引</u>，需要注意的是MySQL5.6以后支持全文索引了，5.6之前是不支持的。

**HASH**：由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。 HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。

**BTREE** ：BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。

**RTREE** ：RTREE在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。 相对于BTREE，RTREE的优势在于范围查找。

#### 5、MySQL索引主要使用的两种数据结构是什么？

哈希索引，对于哈希索引来说，底层的数据结构肯定是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引

BTree索引，Mysql的BTree索引使用的是B树中的B+Tree，BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。

但对于主要的两种存储引擎（MyISAM和InnoDB）的实现方式是不同的。

#### 6、聚集索引与非聚集索引的区别是什么?

聚集索引和非聚集索引的区别在于，通过聚集索引可以查到需要查找的数据，而通过非聚集索引可以查到记录对应的主键值，再使用主键的值通过聚集索引查找到需要的数据。聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。

聚集索引（Innodb）的叶节点就是数据节点，而非聚集索引(MyisAM)的叶节点仍然是索引节点，只不过其包含一个指向对应数据块的指针。

#### 7、**什么时候需要建立数据库索引呢？**

**在最频繁使用的、用以缩小查询范围的字段,需要排序的字段上建立索引。** 

不宜：

 1）对于查询中很少涉及的列或者重复值比较多的列 

2）对于一些特殊的数据类型，不宜建立索引，比如文本字段（text）等。

#### 8、覆盖索引是什么？

**如果一个索引包含所有需要查询的字段的值，我们就称 之为“覆盖索引”。**

我们知道在InnoDB存储引 擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次,这样就会比较慢。

**覆盖索引是一种数据查询方式，不是索引类型**

**在索引数据结构中，通过索引值可以直接找到要查询字段的值，而不需要通过主键值回表查询，那么就叫覆盖索引。**

#### 9、创建索引时需要注意什么？

**非空字段：应该指定列为NOT NULL，除非你想存储NULL。**<u>在 MySQL 中，含有空值的列很难进行查询优化</u>，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；

**取值离散大的字段**：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；

**索引字段越小越好**：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。 唯一、不为空、经常被查询的字段的字段适合建索引。

#### 10、MySQL 索引使用的注意事项

MySQL 索引通常是被用于提高 WHERE 条件的数据行匹配时的搜索速度，在索引的使用过程中，存在一些使用细节和注意事项。

1）不要在列上使用函数，这将导致索引失效而进行全表扫描。

2）尽量避免使用 != 或 not in或 <> 等否定操作符

3）多个单列索引并不是最佳选择

4）复合索引的最左前缀原则

复合索引遵守“最左前缀”原则，即在查询条件中使用了复合索引的第一个字段，索引才会被使用。

5）覆盖索引的好处

如果一个索引包含所有需要的查询的字段的值，直接根据索引的查询结果返回数据，而无需读表，能够极大的提高性能。因此，可以定义一个让索引包含的额外的列，即使这个列对于索引而言是无用的。

6）范围查询对多列查询的影响.

查询中的某个列有范围查询，则其右边所有列都无法使用索引优化查找。 

7）索引不会包含有NULL值的列

只要列中包含有 NULL 值都将不会被包含在索引中，复合索引中只要有一列含有 NULL值，那么这一列对于此复合索引就是无效的。 因此，在数据库设计时，除非有一个很特别的原因使用 NULL 值，不然**尽量不要让字段的默认值为 NULL**。

8）隐式转换的影响

当查询条件左右两侧类型不匹配的时候会发生隐式转换，隐式转换带来的影响就是可能导致索引失效而进行全表扫描。

9）like 语句的索引失效问题

like 的方式进行查询，在 like “value%” 可以使用索引，但是对于 like “%value%” 这样的方式，执行全表查询，这在数据量小的表，不存在性能问题，但是对于海量数据，全表扫描是非常可怕的事情。所以，根据业务需求，考虑使用 ElasticSearch 或 Solr 是个不错的方案。

#### 11、MySQL中有哪些索引？有什么特点？

普通索引：仅加速查询

唯一索引：加速查询 + 列值唯一（可以有null）

主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个

组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并

全文索引：对文本的内容进行分词，进行搜索

索引合并：使用多个单列索引组合搜索

覆盖索引：select的数据列只用从索引中就能够取得，不必读取数据行，换句话说**查询列要被所建的索引覆盖**

聚簇索引：**表数据是和主键一起存储的，主键索引的叶结点存储行数据(包含了主键值)，二级索引的叶结点存储行的主键值。**使用的B+树作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容)

#### 12、既然索引有那么多优点，为什么不对表总的每一列创建一个索引呢？

当对表中的数据进行增、删、改的时候，索引也要动态的维护，这样会降低了数据的维护速度。

每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。

创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加

#### 13、索引如何提高查询速度的

将无序的数据变成相对有序的数据（就像查有目的一样）

#### 14、使用索引的注意事项

① 在经常需要搜索的列上创建索引，可以加快搜索的速度；

② 在经常使用在where子句中的列上面创建索引，加快条件的判断速度。

③ 将打算加索引的列设置为NOT NULL，否则将导致引擎放弃使用索引而进行全表扫描

④ 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间

⑤ 避免where子句中对字段施加函数，这会造成无法命中索引

⑥ 在中到大型表索引都是非常有效的，但是特大型表的维护开销会很大，不适合建索引，建立用逻辑索引

⑦ 在经常用到连续的列上，这些列主要是由一些外键，可以加快连接的速度

⑧ 与业务无关时多使用逻辑主键，也就是自增主键在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。

⑨ 删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗

⑩ 在使用limit offset查询缓存时，可以借助索引来提高性能。

#### 15、MySQL怎么判断要不要加索引？

1. 当唯一性是某种数据本身的特征时，指定唯一索引。使用唯一索引需能确保定义的列的数据完整

性，以提高查询速度。

2. 在频繁进行排序或分组（即进行group by或order by操作）的列上建立索引，如果待排序的列有

多个，可以在这些列上建立组合索引。

#### 16、**只要创建了索引，就一定会走索引吗？**

不一定。

使用组合索引的时候，如果没有遵从“最左前缀”的原则进行搜索，则索引是不起作用的。

举例，假设在id、name、age字段上已经成功建立了一个名为MultiIdx的组合索引。索引行中按id、name、age的顺序存放，索引可以搜索id、（id,name）、（id, name, age）字段组合。如果列不构成索引最左面的前缀，那么MySQL不能使用局部索引，如（age）或者（name,age）组合则不能使用该索引查询。

#### 17、**如何判断数据库的索引有没有生效？**

**可以使用EXPLAIN语句查看索引是否正在使用。**

举例，假设已经创建了book表，并已经在其year_publication字段上建立了普通索引。执行如下语句：

```sql
EXPLAIN SELECT * FROM book WHERE year_publication=1990;
```

EXPLAIN语句将为我们输出详细的SQL执行信息，其中：

- possible_keys行给出了MySQL在搜索数据记录时可选用的各个索引。
- key行是MySQL实际选用的索引。

如果possible_keys行和key行都包含year_publication字段，则说明在查询时使用了该索引。

#### 18、**如何评估一个索引创建的是否合理？**

建议按照如下的原则来设计索引：

1. **避免对经常更新的表进行过多的索引**，并且索引中的列要尽可能少。应该经常用于查询的字段创建

索引，但要避免添加不必要的字段。

2. **数据量小的表最好不要使用索引**，由于数据较少，查询花费的时间可能比遍历索引的时间还要短，

索引可能不会产生优化效果。

3. **在条件表达式中经常用到的不同值较多的列上建立索引，在不同值很少的列上不要建立索引。**比如在学生表的“性别”字段上只有“男”与“女”两个不同值，因此就无须建立索引，如果建立索引不但不会提高查询效率，反而会严重降低数据更新速度。

4. **当唯一性是某种数据本身的特征时，指定唯一索引。**使用唯一索引需能确保定义的列的数据完整性，以提高查询速度。

5. **在频繁进行排序或分组（即进行group by或order by操作）的列上建立索引**，如果待排序的列有多个，可以在这些列上建立组合索引。

#### 19、**所有的字段都适合创建索引吗？**

不是。

下列几种情况，是不适合创建索引的：

1. 频繁更新的字段不适合建立索引；

2. where条件中用不到的字段不适合建立索引；

3. 数据比较少的表不需要建索引；

4. 数据重复且分布比较均匀的的字段不适合建索引，例如性别、真假值；

5. 参与列计算的列不适合建索引。

#### 20、都知道数据库索引采用B+树而不是B树，原因也有很多，主要原因是什么？

主要原因：**B+树只要遍历叶子节点就可以实现整棵树的遍历**，而且在**数据库中基于范围的查询是非常频繁的**，而B树只能中序遍历所有节点，效率太低。

**那为什么不用二叉查找树、红黑树呢？**

二叉查找树有一种极端情况，当所插入的元素都是更大的元素时，我们去查找它就成为了线性查找，所需的时间复杂度也由之变大。

红黑树的话，它主要点在于会自我平衡（弱自平衡二叉搜索树），但是随着数据量的增多，它会变得越来越高，导致查询会很慢。

B树：叶子节点具有相同深度，叶子节点指针为空，所有索引元素不重复，节点中的数据索引从左到右递增排列。预先分配大的磁盘空间，里面能够存放更多索引元素

#### 21、文件索引和数据库索引为什么使用B+树?

文件与数据库都是需要较大的存储，也就是说，它们都不可能全部存储在内存中，故需要存储到磁盘上。而所谓索引，则为了数据的快速定位与查找，那么索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数，因此B+树相比B树更为合适。

最重要的是，**B+树还有一个最大的好处：方便扫库。**

B+树查找效率更加稳定，B树有可能在中间节点找到数据，稳定性不够。

#### 22、**为什么说B+tree比B 树更适合实际应用中操作系统的文件索引和数据库索引？**

B+tree的磁盘读写代价更低，B+tree的查询效率更加稳定，数据库索引采用B+树而不是B树的主要原因：B+树只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的，而B树只能中序遍历所有节点，效率太低。

**B+树的特点**

所有关键字都出现在叶子结点的链表中(稠密索引)，且链表中的关键字恰好是有序的;

不可能在非叶子结点命中;

非叶子结点相当于是叶子结点的索引(稀疏索引)，叶子结点相当于是存储(关键字)数据的数据层;

#### 23、增加B+树的路数可以降低树的高度，那么无限增加树的路数是不是可以有最优的查找效率？

不可以。因为这样会形成一个有序数组，文件系统和数据库的索引都是存在硬盘上的，并且如果数据量大的话，不一定能一次性加载到内存中。有序数组没法一次性加载进内存，这时候B+树的多路存储威力就出来了，可以每次加载B+树的一个结点，然后一步步往下找。

#### 24、为什么MySQL索引要使用B+树，而不是B树或者红黑树？

我们在MySQL中的数据一般是放在磁盘中的，读取数据的时候肯定会有访问磁盘的操作，当大规模数据存储到磁盘中的时候，显然定位是一个非常花费时间的过程，但是我们可以通过B树进行优化，提高磁盘读取时定位的效率。

为什么B类树可以进行优化呢？我们可以根据B类树的特点，**构造一个多阶的B类树**，然后在尽量多的在结点上存储相关的信息，保证层数（树的高度）尽量的少，以便后面我们可以更快的找到信息，磁盘的I/O操作也少一些，而且B类树是平衡树，每个结点到叶子结点的高度都是相同，这也保证了每个查询是稳定的。

特别地：只有B-树和B+树，这里的B-树是叫B树，不是B减树，没有B减树的说法。

#### 25、为什么MySQL索引适用用B+树而不用hash表和B树？

利用Hash需要把数据全部加载到内存中，如果数据量大，是一件很消耗内存的事，而采用B+树，是基于按照节点分段加载，由此减少内存消耗。

和业务场景有段，对于唯一查找（查找一个值），Hash确实更快，但数据库中经常查询多条数据，这时候由于B+数据的有序性，与叶子节点又有链表相连，他的查询效率会比Hash快的多。

hash索引不支持模糊查询以及多列索引的最左前缀匹配，原理也是因为hash函数的不可预测。

hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。

b+树的非叶子节点不保存数据，只保存子树的临界值（最大或者最小）（作为索引），所以同样大小的节点，b+树相对于b树能够有更多的分支，使得这棵树更加矮胖，查询时做的IO操作次数也更少。

#### 26、既然Hash比B+树更快，为什么MySQL用B+树来存储索引呢？

MySQL中存储索引用到的数据结构是B+树，B+树的查询时间跟树的高度有关，是log(n)，如果用hash存储，那么查询时间是O(1)。

采用Hash来存储确实要更快，但是采用B+树来存储索引的原因主要有以下两点：

**一、从内存角度上说**，数据库中的索引一般是在磁盘上，数据量大的情况可能无法一次性装入内存，B+树的设计可以允许数据分批加载。

**二、从业务场景上说**，如果只选择一个数据那确实是hash更快，但是数据库中经常会选中多条，这时候由于B+树索引有序，并且又有链表相连，它的查询效率比hash就快很多了。

#### 27、**联合索引的存储结构是什么，它的有效方式是什么？**

**从本质上来说，联合索引还是一棵B+树，不同的是联合索引的键值数量不是1，而是大于等于2**，参考下图。另外，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，所以**使用联合索引时遵循最左前缀集合。**

![image-20220803174035612](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220803174035612.png)



#### **28、说一说索引的实现原理**

在MySQL中，索引是在存储引擎层实现的，不同存储引擎对索引的实现方式是不同的，下面我们探讨一下MyISAM和InnoDB两个存储引擎的索引实现方式。

MyISAM索引实现：

**MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址**，在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。

InnoDB索引实现：

虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。

**第一个重大区别是InnoDB的数据文件本身就是索引文件，叶节点data域保存了完整的数据记录。**这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集。

所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。

第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。

聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。

#### **29、聚簇索引和非聚簇索引有什么区别？**

- 在InnoDB存储引擎中，可以将B+树索引分为聚簇索引和辅助索引（非聚簇索引）。无论是何种索引，每个页的大小都为16KB，且不能更改。

- 聚簇索引是根据主键创建的一棵B+树，**聚簇索引的叶子节点存放了表中的所有记录**。**辅助索引**是根据索引键创建的一棵B+树，与聚簇索引不同的是，**其叶子节点仅存放索引键值**，**以及该索引键值指向的主键。**也就是说，如果通过辅助索引来查找数据，那么当找到辅助索引的叶子节点后，很有可能还需要根据主键值查找聚簇索引来得到数据，这种查找方式又被称为书签查找。因为辅助索引不包含行记录的所有数据，这就意味着每页可以存放更多的键值，因此其高度一般都要小于聚簇索引。

#### 30、select in语句中如何使用索引？

索引是否起作用，主要取决于字段类型：

- 如果字段类型为字符串，需要给in查询中的数值与字符串值都需要添加引号，索引才能起作用。
- 如果字段类型为int，则in查询中的值不需要添加引号，索引也会起作用。

IN的字段，在联合索引中，按以上方法，也会起作用。

#### 31、**模糊查询语句中如何使用索引？**

在MySQL中模糊查询 mobile like ‘%8765’ ，这种情况是不能使用 mobile 上的索引的，那么如果需要根据手机号码后四位进行模糊查询，可以用一下方法进行改造。

我们可以加入冗余列（MySQL5.7之后加入了虚拟列，使用虚拟列更合适，思路相同），比如mobile_reverse，内部存储为 mobile 的倒叙文本，如 mobile为17312345678，那么mobile_reverse存储 87654321371，为 mobile_reverse 列建立索引，查询中使用语句 mobile_reverse like reverse(’%5678’) 即可。reverse 是 MySQL 中的反转函数，这条语句相当于 mobile_reverse like ‘8765%’ ，这种语句是可以使用索引的。

### 二、存储引擎

#### 32、MySQL常见的存储引擎 InnoDB、MyISAM的区别？适用场景分别是？

1. 事务：MyISAM不支持，InnoDB支持 
2. 锁级别： MyISAM 表级锁，InnoDB 行级锁及外键约束 
3. MyISAM存储表的总行数；InnoDB不存储总行数； 
4. MyISAM采用非聚集索引，B+树叶子存储指向数据文件的指针。InnoDB主键索引采用聚集索引，B+树叶子存储数据
5. 适用场景： MyISAM适合： 插入不频繁，查询非常频繁，如果执行大量的SELECT，MyISAM是更好的选择， 没有事务。 InnoDB适合： 可靠性要求比较高，或者要求事务； 表更新和查询都相当的频繁的场合。

#### 33、数据库引擎InnoDB与MyISAM的区别

- 事务: InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。
- 并发: MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
- 外键: InnoDB 支持外键。
- 备份: InnoDB 支持在线热备份。
- 崩溃恢复: MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
- 其它特性: MyISAM 支持压缩表和空间数据索引。

#### 35、Innodb为什么要用自增id作为主键？

- 如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。
- 如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页的中间某个位置， 频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE（optimize table）来重建表并优化填充页面。

#### 36、MyISAM和InnoDB实现B树索引方式的区别是什么？

① MyISAM，B+Tree叶节点的data域存放的是数据记录的地址，在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录，这被称为“非聚簇索引” 

② InnoDB，其数据文件本身就是索引文件，相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的节点data域保存了完整的数据记录，这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引，这被称为“聚簇索引”或者聚集索引，而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。

在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。因此，在设计表的时候，不建议使用过长的字段为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。