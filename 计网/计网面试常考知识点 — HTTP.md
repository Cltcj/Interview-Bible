### 计网面试常考知识点 — HTTP 46 问

#### 1、你知道DNS是什么？

- 域名系统，因特网上作为域名和IP地址进行映射的一个分布式数据库，使用户方便访问互联网，不需要去记住能够被机器识别的IP地址
- **通过主机名，最终得到该主机对应的IP地址的过程称为域名解析。**

#### 2、DNS的工作原理？

- 将主机域名转换为ip地址，属于应用层协议，使用UDP进行传输。

#### 3、简述域名解析过程？

- 先在浏览器中找之前有没有缓存过的域名对应的ip地址，有的话，直接跳过dns解析，没有的话，就会查找硬盘的hosts文件，，有的话，直接找到hosts文件里面的ip返回。
- 如果本地的hosts文件没有得到对应的ip地址，浏览器会发送一个dns请求到本地dns服务器，本地dns服务器一般都是你的网络接入服务器商提供。
- 查询你输入的网址的DNS请求到达本地DNS服务器后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就直接返回结果，此过程是递归的方式进行查询。
- 如果没有，本地DNS服务器还要向DNS根服务器进行查询，根服务器会返回一个管理该域名的顶级域名服务器的IP给本地服务器。
- 本地DNS服务器继续向域服务器发送请求，域服务器会告诉本地服务器，你的域名的解析服务器的地址。
- 最后本地DNS服务器向域名的解析服务器发送请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还会把这个对应关系保存在缓存中，以备下一次用户查找可以直接返回，加快网络访问。
- **注意：**
  - 主机向本地域名服务器的查询一般都是采用递归查询。
  - 本地域名服务器向根域名服务器的查询是迭代查询

#### 4、本机如何干预域名解析？

- 通过修改本机host来干预域名解析，例如：
- 在/etc/hosts文件中添加一句话：`192.169.188.1 www.baidu.com`
- 保存文件后再ping一下www.baidu.com就会连接到192.168.188.1了
- 每一行为一条记录，分成两部分，第一部分是IP，第二部分是域名。
- 一个IP后面可以跟多个域名，可以是几十个甚至上百个
- 每一行只能有一个IP，也就是说一个域名不能对应多个IP，如果有多行中出现相同的域名（对应的ip不一样），会按最前面的记录来解析

#### 5、查询服务器的基本流程是什么？

- 打开浏览器，输入一个域名。比如输入www.163.com，这时，你使用的电脑会发出一个DNS请求到本地DNS服务器。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。
- DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果。如果没有，本地DNS服务器还要向DNS根服务器进行查询。
- 根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。
- 本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。
- 最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。

####  6、DNS 劫持是什么？

-  DNS劫持就是通过劫持了DNS服务器，**通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP，**其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。DNS劫持通过篡改DNS服务器上的数据返回给用户一个错误的查询结果来实现的。
- DNS劫持症状：在某些地区的用户在成功连接宽带后，首次打开任何页面都指向ISP提供的“电信互联星空”、“网通黄页广告”等内容页面。还有就是曾经出现过用户访问Google域名的时候出现了百度的网站。这些都属于DNS劫持。

#### 7、DNS负载均衡是什么策略？

- 当一个网址有足够多的用户的时候，假如每次请求的资源位于同一台机器上面，那么这台机器随时可能会蹦掉。处理方法是用DNS负载均衡技术，它的**原理是在DNS服务器中为同一个主机名配置多个IP地址**，在应答DNS查询时，DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果，将客户端的访问引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的，如根据每台机器的负载量，该机器离用户地理位置等。

#### 8、**DNS查询方式有哪些？**

- 递归解析
  - 当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。此时有两种方式。局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。
- 迭代解析
  - 当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析。局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。

#### 9、HTTP是什么？

http是超文本传输协议的简称。

1. http是用于从万维网服务器传输超文本到本地浏览器的传送协议。
2. http是万维网上能够可靠交换文件的重要基础。
3. HTTP是一个 客户端和服务器端请求和应答的标准。

#### 10、说一下一次完整的HTTP请求过程包括哪些内容？（在浏览器中输入url地址后显示主页的过程？）

1. 根据域名进行DNS域名解析
2. 发起TCP三次握手建立TCP连接
3.  建立TCP连接后进行HTTP请求
4. 服务器响应HTTP请求，浏览器得到html代码
5. 浏览器解析html代码并请求html中的资源（如js、css、图片等）
6. 浏览器对页面进行渲染呈现给用户

#### 11、在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？

- 浏览器检查域名是否在缓存中。
- 如果缓存中没有，就调用 gethostbyname 库函数进行查询（操作系统不同，库函数不同）
- 如何没有这个域名的缓存记录，它将会向本地 DNS 服务器发送一条 DNS 查询请求
- 查询本地 DNS 服务器
- 如果 DNS 服务器和我们的主机在同一个子网内，系统会按照下面 ARP 过程对 DNS 服务器进行 ARP查询
- 如果 DNS 服务器和我们的主机在不同的子网，系统会按照下面的 ARP 过程对默认网关进行查询

#### 12、**说说HTTP的方法有哪些**

- GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器
- POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。
- PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。
- HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。
- DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。
- OPTIONS：查询相应URI支持的HTTP方法。

#### **13、说说HTTP常见的响应状态码及其含义**

- **200** : 从状态码发出的请求被服务器正常处理。
- **204** : 服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分【即没有内容】。
- **206** : 表示客户端进行了范围请求，响应报文包含由Content-Range指定范围的实体内容。
- **301** : 跳转，代表永久性重定向（请求的资源已被分配了新的URI，以后已使用资源，现在设置了URI）。
- **302** : 临时性重定向（请求的资源已经分配了新的URI，希望用户本次能够使用新的URI来进行访问）。
- **303** : 由于请求对应的资源存在的另一个URI（因使用get方法，定向获取请求的资源）。
- **304** : 客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回了 304。
- **307** : 临时重定向【该状态码与302有着相同的含义】。
- **400** : 请求报文中存在语法错误（当错误方式时，需修改请求的内容后，再次发送请求）。
- **401** : 发送的请求需要有通过HTTP认证的认证信息。
- **403** : 对请求资源的访问被服务器拒绝了。
- **404** : 服务器上无法找到请求的资源。
- **500** : 服务器端在执行请求时发生了错误。
- **503** : 服务器暂时处于超负载或者是正在进行停机维护，现在无法处理请求。
- **总结：**
  - 1XX : 信息类状态码（表示接收请求状态处理）
  - 2XX : 成功状态码（表示请求正常处理完毕）
  - 3XX : 重定向（表示需要进行附加操作，已完成请求）
  - 4XX : 客户端错误（表示服务器无法处理请求）
  - 5XX : 服务器错误状态码（表示服务器处理请求的时候出错）

#### 14、HTTP长连接和短连接的区别？

- 在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。
- 而从HTTP/1.1起，默认使用长连接，用以保持连接特性。

#### 15、简述 HTTP 1.0，1.1，2.0的主要区别

**http/1.0 :**

1. 默认不支持长连接，需要设置keep-alive参数指定

2. 强缓存expired、协商缓存last-modifified\if-modifified-since 有一定的缺陷

**http 1.1 :**

1. 默认长连接(keep-alive)，http请求可以复用Tcp连接，但是**同一时间只能对应一个http请求**(http请求在一个Tcp中是串行的) 

2. 增加了强缓存cache-control、协商缓存etag\if-none-match 是对http/1 缓存的优化

**http/2.0 :**

1. 多路复用，一个Tcp中多个http请求是并行的 (雪碧图、多域名散列等优化手段http/2中将变得多余) 

2. 二进制格式编码传输

3. 使用HPACK算法做header压缩

4. 服务端推送

#### 16、HTTP如何禁用缓存？如何确认缓存？

HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。

**禁止进行缓存**

no-store 指令规定不能对请求或响应的任何一部分进行缓存。

**强制确认缓存**

no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。

#### 17、说说GET请求和POST请求的区别

1. GET请求在URL中传送的参数是有长度限制的，而POST没有。
2. GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
3.  GET参数通过URL传递，POST放在Request body中。

4. GET请求会被浏览器主动缓存，而POST不会，除非手动设置。

5. GET请求只能进行url编码，而POST支持多种编码方式。

6. GET请求会被浏览器主动cache，而POST不会，除非手动设置。

7. GET产生的URL地址可以被Bookmark，而POST不可以。

8. GET在浏览器回退时是无害的，而POST会再次提交请求。

#### **18、GET 方法参数写法是固定的吗？**

- **一般来说，Get的参数是写在 ? 后面，用 & 分割。**
- 我们知道，解析报文的过程是通过获取 TCP 数据，用正则等工具从数据中获取 Header 和 Body，从而提取参数。
- 比如header请求头中添加token，来验证用户是否登录等权限问题。
- **也就是说，我们可以自己约定参数的写法，只要服务端能够解释出来就行，万变不离其宗。**

#### **19、GET 方法的长度限制是怎么回事？**

- 网络上都会提到浏览器地址栏输入的参数是有限的。
- 首先说明一点，HTTP 协议没有 Body 和 URL 的长度限制，对 URL 限制的大多是浏览器和服务器的原因。浏览器原因就不说了，服务器是因为处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制。

#### 20、**GET与POST传递数据的最大长度能够达到多少呢？**

- <u>get 是通过URL提交数据，因此GET可提交的数据量就跟URL所能达到的最大长度有直接关系。</u>

- <u>post 理论上讲是没有大小限制的，HTTP协议规范也没有进行大小限制，但实际上post所能传递的数据量大小取决于服务器的设置和内存大小。</u>

#### 21、POST 方法比 GET 方法安全？

- 有人说POST 比 GET 安全，因为数据在地址栏上不可见。
- 然而，从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文。
- 要想安全传输，就只有加密，也就是 HTTPS。

#### **22、POST 方法会产生两个 TCP 数据包？你了解吗？**

- 有些文章中提到，POST 会将 header 和 body 分开发送，先发送 header，服务端返回 100 状态码再发送 body。
- **HTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，而且实际测试(Chrome)发现，header 和 body 不会分开发送。**
- **所以，header 和 body 分开发送是部分浏览器或框架的请求方法，不属于 post 必然行为。**

#### 23、HTTP请求和响应报文有哪些主要字段？

请求报文

简单来说：请求行、请求头、请求体

响应报文：

简单来说：状态行、响应头、响应体

#### 24、**HTTPS 是什么？**

HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。

#### 25、**HTTP的缺点有哪些？**

使用明文进行通信，内容可能会被窃听；

不验证通信方的身份，通信方的身份有可能遭遇伪装；

无法证明报文的完整性，报文有可能遭篡改。

#### 26、HTTPS和HTTP区别

- HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，HTTPS协议是由SSL+HTTP协议构建的可以进行加密传输、身份认证的网络协议，要比http协议安全。
- https协议需要用到ca申请证书，一般免费证书较少，因而需要一定费用。
- http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443

#### 27、什么是SSL/TLS？

- **SSL代表安全套接字层。**它是一种用于加密和验证应用程序（如浏览器）和web服务器之间发送的数据的协议。身份验证，Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。
- **SST/TLS协议作用：认证用户和服务，加密数据，维护数据的完整性的应用层协议**
- 加密和解密需要两个不同的密钥，故称为非对称加密，加密和解密都使用同一个密钥的称为对称加密
- 对称加密：优点在于加密、解密效率通常比较高，HTTPS是基于非对称加密的，公钥是公开的。

#### 28、**对称密钥加密的优点缺点？**

对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。

优点：运算速度快

缺点：无法安全地将密钥传输给通信方

#### 29、**非对称密钥加密你了解吗？优缺点？**

非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。

公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。

**非对称密钥除了用来加密，还可以用来进行签名。**因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。

优点：可以更安全地将公开密钥传输给通信发送方；

缺点：运算速度慢。

#### 30、HTTPS是如何保证数据传输的安全，整体流程是什么？

1. 客户端向服务器发送SSL连接请求。

2. 服务器把公钥发送给客户端。并且服务端保存着唯一的私钥

3. 客户端用公钥对双方通信的对称密钥进行加密，并发送给服务器端

4. 服务器利用自己唯一的私钥对客户端发来的对称密钥进行解密。

5. 进行数据传输，服务器和客户端双方公有的相同的对称密钥对数据进行加密解密，可以保证在数据收发过程中的安全，即是第三方获得数据包，也无法对其加密，解密和篡改。

   SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。

#### 31、如何保证公钥不被篡改？

- 将公钥放在数字证书中，只要证书是可信的，公钥就是可信的。

#### 32、公钥加密计算量太大，如何减少消耗时？

每一次对话（session），客户端和服务端都生成一个“对话密钥”，用它来加密信息。由于“对话密钥”是对称加密，所以运行速度非常快，而服务器公钥只用于加密“对话密钥”本身，这样就减少了加密运算的消耗时间。

1. 客户端向服务器索要并验证公钥
2. 双方协商生成“对话密钥”
3. 双方采用“对话密钥”进行加密通信。

#### 33、**为什么有的时候刷新页面不需要重新建立 SSL 连接？**

TCP 连接有的时候会被浏览器和服务端维持一段时间，TCP 不需要重新建立，SSL 自然也会用之前的。

#### 34、**浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？**

**在 HTTP/1.0 中，一个服务器在发送完一个 HTTP 响应后，会断开 TCP 链接。**但是这样每次请求都会重新建立和断开 TCP 连接，代价过大。所以虽然标准中没有设定，某些服务器对 Connection: keep-alive 的 Header 进行了支持。意思是说，完成这个 HTTP 请求之后，不要断开 HTTP 请求使用的 TCP 连接。这样的好处是连接可以被重新使用，之后发送 HTTP 请求的时候不需要重新建立 TCP 连接，以及如果维持连接，那么 SSL 的开销也可以避免。

持久连接：既然维持 TCP 连接好处这么多，HTTP/1.1 就把 Connection 头写进标准，并且默认开启持久连接，除非请求中写明 Connection: close，那么浏览器和服务器之间是会维持一段时间的 TCP 连接，不会一个请求结束就断掉。

默认情况下建立 TCP 连接不会断开，只有在请求报头中声明 Connection: close 才会在请求完成后关闭连接。

#### 35、SSL中的认证中的证书是什么？了解过吗？

通过使用 **证书** 来对通信方进行认证。

数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。

服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。

进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。

#### 36、**HTTP中有个缓存机制，但如何保证缓存是最新的呢？（缓存过期机制）**

max-age 指令出现在<u>请求报文</u>，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。

max-age 指令出现在<u>响应报文</u>，表示缓存资源在缓存服务器中保存的时间。

Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。

在 HTTP/1.1 中，会优先处理 max-age 指令；

在 HTTP/1.0 中，max-age 指令会被忽略掉。

#### 37、HTTP中缓存的私有和公有字段？知道吗？

private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。

public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。

#### 38、Cookie是什么？

HTTP协议是无状态的，主要为了让HTTP协议尽可能简单，使得它能够处理大量事务，HTTP/1.1引入**Cookie来保存状态信息。**

**Cookie是服务器发送到用户浏览器并保存在本地的一小块数据**，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带Cookie数据，因此会带来额外的性能开销（尤其在移动环境下）。

#### 39、**Session是什么？**

除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。

Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。

#### 40、Cookie的用途？

会话状态管理（用户登录状态、购物车、游戏分数或其它需要记录的信息）

个性化设置（如用户自定义设置、主题等）

浏览器行为跟踪（如跟踪分析用户行为等）

#### 41、**说说** **Cookie** **和** **Session** **的关系和区别是什么**

1. **Cookie与Session都是会话的一种方式。**它们的典型使用场景比如“购物车”，当你点击下单按钮时，服务端并不清楚具体用户的具体操作，为了标识并跟踪该用户，了解购物车中有几样物品，服务端通过为该用户创建Cookie/Session来获取这些信息。

2. **cookie数据存放在客户的浏览器上，session数据放在服务器上。**

3. cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。 

4. session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。 

5. 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。

#### 42、Session 的工作原理是什么？

Session的工作原理是客户端登录完成之后，服务器会创建对应的Session，Session创建完之后，会把Session中的id发送给客户端，客户端再存储到浏览器中，这样客户端每次访问服务器时，都会带着Session ID，服务器拿到sessionid之后，在内存找到与之对应的session这样就能正常工作了。

#### 43、Session 和 Cookie对比

**Cookie是客户端保持状态的方法。**

- Cookie简单的理解就是存储来自服务器发送至客户端保存的一段字符串。为了保持会话，服务器可以在响应客户端请求时将Cookie字符串放在Set-Cookie下，客户机收到Cookie之后会保存这段字符串，之后再请求时带上Cookie就能被识别。

Cookie在客户端的保存形式有两种，一种是会话Cookie一种是持久Cookie

**Session是服务器保存状态的方法**

- Session保存在服务器上，可以保存在数据库、文件或内存中，每个用户有独立的Session用户在客户端上记录用户的操作，我们可以理解为每个用户有一个独一无二的SessionID作为Session文件的Hash键，通过这个值可以锁定具体的Session结构的数据，这个Session结构中存储了用户操作的行为。

#### 44、**使用** **Session** **的过程是怎样的？**

1. 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；
2. 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；
3. 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；
4. 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。

注意：Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。

#### 45、Session 和 cookie应该如何去选择（适用场景）？

Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；

Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；

对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。

#### 46、**Cookies和Session区别是什么？**

**Cookie和Session都是客户端与服务器之间保持状态的解决方案**

**①** **存储的位置不同**，cookie：存放在客户端，session：存放在服务端。Session存储的数据比较安全

**②** **存储的数据类型不同**，两者都是key-value的结构，但针对value的类型是有差异的 cookie：value只能是字符串类型，session：value是Object类型 

**③** **存储的数据大小限制不同**，cookie：大小受浏览器的限制，很多是是4K的大小， session：理论上受当前内存的限制

**④** **生命周期的控制** cookie的生命周期当浏览器关闭的时候，就消亡了 

(1) cookie的生命周期是**累计的**，从创建时，就开始计时，20分钟后，cookie生命周期结束， 

(2) session的生命周期是**间隔的**，从创建时，开始计时如在20分钟，没有访问session，那么session生命周期被销毁









