### 计网面试常考知识点 — TCP、UDP篇

- [x] #### **1、TCP是什么？**

  - TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、**基于字节流**的传输层通信协议。

- [x] #### **2、UDP是什么？**

  - 提供无连接的，面向报文的，尽最大努力的数据传输服务（即不保证数据传输的可靠性）。

- [x] #### **3、TCP和UDP的区别？**

  - **TCP面向连接**，**UDP是无连接的**(即发送数据之前不需要建立连接)
  - **TCP提供可靠的服务**。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;**UDP尽最大努力交付**，即不保证可靠交付
  - **TCP面向字节流**，实际上是TCP把数据看成一连串无结构的字节流，它把上面应用层交下来的数据看成无结构的字节流会发送，发送方TCP会将数据放入缓存区，等到可以发送的时候就发送，不能发送就等着TCP会根据当前网络的拥塞状态来确定每个报文段的大小。

  - **UDP是面向报文的**，发送方的UDP对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层，论应用层交给UDP多长的报文，它统统发送，一次发送一个。而对接收方，接到后直接去除首部，交给上面的应用层就完成任务了。因此，它需要应用层控制报文的大小
  - **UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）**
  - 每一条**TCP连接只能是点到点的**，**UDP支持一对一**，一对多，多对一和多对多的交互通信
  - **TCP首部开销20字节**，**UDP的首部开销小，只有8个字节**
  - **TCP**的逻辑通信信道是**全双工**的可靠信道，**UDP**则是**不可靠的信道**

- [x] #### **4、TCP、UDP的头部结构是什么样的?**

```C++
/*TCP头定义，共20个字节*/ 
typedef struct _TCP_HEADER {
    short m_sSourPort; // 源端口号16bit 
    short m_sDestPort; // 目的端口号16bit 
    unsigned int m_uiSequNum; // 序列号32bit 
    unsigned int m_uiAcknowledgeNum; // 确认号32bit 
    short m_sHeaderLenAndFlag; // 前4位：TCP头长度；中6位：保留；后6位：标志位
    short m_sWindowSize; // 窗口大小16bit 
    short m_sCheckSum; // 检验和16bit short
    m_surgentPointer; // 紧急数据偏移量16bit 
}__attribute__((packed))TCP_HEADER, *PTCP_HEADER;

/*UDP头定义，共8个字节*/ 
typedef struct _UDP_HEADER {
    unsigned short m_usSourPort; // 源端口号16bit 
    unsigned short m_usDestPort; // 目的端口号16bit 
    unsigned short m_usLength; // 数据包长度16bit 
    unsigned short m_usCheckSum; // 校验和16bit
}__attribute__((packed))UDP_HEADER, *PUDP_HEADER; 
```



- [x] #### **5、TCP 协议如何保证可靠传输？**

  - 建立连接（标志位）：通信前确认通信实体存在。
  - 序号机制（序号、确认号）：确保了数据是按序、完整到达。
  - 数据校验（校验和）：CRC校验全部数据。
  - 超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。
  - 滑动窗口（窗口）：提供流量控制，避免过量发送。
  - 拥塞控制：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。

- [x] #### **6、首部数据校验，这个校验机制能够确保数据传输不会出错吗？**

  - **不能确保数据传输不出错**
  - **原因：**
    -  因为为TCP首部校验方式是累加和，也就是将一系列的数字（TCP协议规定的是数据中的每16个比特位数据作为一个数字）求和后取末位。 但是A+B = B+A，假如在传输的过程中有前后两个16比特位的数据前后颠倒了，那么校验和的计算结果和颠倒之前是一样的，那么接收端肯定无法检查出这是错误的数据。

- [x] #### **7、域名解析用TDP还是UDP？**

  - 域名解析用UDP协议，因为UDP快，**UDP是无连接的**，面向报文的，尽最大努力的数据传输服务，**只要一个请求、一个应答就好了**。
  - 如果是基于TCP的DNS协议，则需要三次握手、发送数据以及应答、四次挥手。
  - 对于UDP协议传输内容不能超过512字节这个问题。其实客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，所以用UDP传输即可。

- [x] #### **8、MTU和MSS分别是什么？**

  - **MTU：maximum transmission unit，最大传输单元**，由硬件规定，如以太网的MTU为1500字节。
  - **MSS：maximum segment size，最大分节大小**，**为TCP数据包每次传输的最大数据分段大小**，一般由发送端向对端TCP通知对端在每个分节中能发送的最大TCP数据。MSS值为MTU值减去IPv4 Header（20 Byte）和TCP header（20 Byte）得到。

- [x] #### **9、封包和拆包你听说过吗？它是基于TCP还是UDP的？**

  - 基于TCP的，因为TCP是面向字节流的。
  - **封包**：封包就是在发送数据报的时候为每个TCP数据报加上一个包头，将数据报分为包头和包体两个部分。包头是一个固定长度的结构体，里面包含该数据包的总长度。
  - **拆包**：接收方在接收到报文后提取包头中的长度信息进行截取。

- [x] #### **10、什么是TCP粘包/拆包？发生的原因，有什么解决方案呢？**

  - **TCP是个“流”协议**，所谓流，就是没有界限的一串数据。大家可以想想河里的流水，是连成一片的，其间并没有分界线。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，**一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。**
  - **原因：**
    - 1、**应用程序写入数据的字节大小大于套接字发送缓冲区的大小。**
    - 2、进行MSS大小的TCP分段。（MSS=TCP报文段长度-TCP首部长度）
    - 3、以太网的payload大于MTU进行IP 分片。（MTU指：一种通信协议的某一层上面所能通过的最大数据包大小。）
  - **解决方案：**
    - 1、消息定长
    - 2、在包尾增加回车或者空格符等特殊字符进行分割
    - 3、将消息分为消息头和消息尾
    - 4、使用其它复杂的协议，如RTMP协议。

- [x] #### **11、一个TCP连接连接中HTTP请求发送可以一起发送吗（比如一起发三个请求，再三个响应一起接收）？**

  - HTTP/1.1中：**单个TCP连接在同一时刻只能处理一个请求**，意思是说：两个请求的生命周期不能重叠，任意两个HTTP请求从开始到结束的时间在同一个TCP连接不能重叠。不过，在HTTP/1.1存在Pipelining技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的，
  - HTTP2中由于Multiplexing特点的存在，**多个HTTP请求可以在同一个TCP连接中并行进行**。
  - **那么HTTP/1.1的时代，浏览器是如何提高页面加载效率呢？**
    - 维持和服务器已经建立的TCP连接，在同一连接上顺序处理多个请求
    - 和服务器**建立多个TCP连接**

- [x] #### **12、TCP头部中包含哪些信息？**

  - 源端口号和目的端口号。源端口号就是指本地端口，目的端口就是远程端口。
  - **序号（32bit）：传输方向上字节流的字节编号。初始时序号会被设置一个随机的初始值（ISN）**，之后每次发送数据时，序号值 = ISN + 数据在整个字节流中的偏移。
  - 确认号（32bit）：接收方对发送方TCP报文段的响应，其值是收到的序号值 + 1。
  - 首部长（4bit）：标识首部有多少个4字节 * 首部长，最大为15，即60字节。
  - 标志位（6bit）：
    - URG：标志紧急指针是否有效。
    - ACK：标志确认号是否有效（确认报文段）。用于解决丢包问题。
    - PSH：提示接收端立即从缓冲读走数据。
    - RST：表示要求对方重新建立连接（复位报文段）。
    - SYN：表示请求建立一个连接（连接报文段）。
    - FIN：表示关闭连接（断开报文段）。
    - 窗口（16bit）：接收窗口。用于告知对方（发送方）本方的缓冲还能接收多少字节数据。用于解决流控。
    - 校验和（16bit）：接收端用CRC检验整个报文段有无损坏。

- [x] #### **13、常见TCP的连接状态有哪些？**

  - CLOSED：初始状态。
  - LISTEN：服务器处于监听状态。
  - SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态。
  - SYN_RECV：服务端收到SYN包并发送服务端SYN包，进入此状态。
  - ESTABLISH：表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态。
  - FIN_WAIT_1：终止连接的一方（通常是客户机）发送了FIN报文后进入。等待对方FIN。
  - CLOSE_WAIT：**（假设服务器）接收到客户机FIN包之后等待关闭的阶段。**在接收到对方的FIN包之后，自然是需要立即回复ACK包的，表示已经知道断开请求。**但是本方是否立即断开连接（发送FIN包）取决于是否还有数据需要发送给客户端，**若有，则在发送FIN包之前均为此状态。
  - FIN_WAIT_2：**此时是半连接状态，即有一方要求关闭连接，等待另一方关闭。**客户端接收到服务器的ACK包，但并没有立即接收到服务端的FIN包，进入FIN_WAIT_2状态。
  - LAST_ACK：服务端发动最后的FIN包，等待最后的客户端ACK响应，进入此状态。
  - TIME_WAIT：客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态。

- [x] #### **14、三次握手**

  - 三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用：
    - 确认双方的接收能力和发送能力是否正常
    - 指定自己的初始化序列号为后面的可靠性传送做准备。
  - **详细步骤：**
  - **第一种答案：**
    - 初始状态：客户端处于 closed(关闭)状态，服务器处于 listen(监听) 状态。
    - 第一次握手：客户端发送请求报文将 SYN = 1同步序列号和初始化序列号seq = x发送给服务端，发送完之后客户端处于SYN_Send状态。（验证了客户端的发送能力和服务端的接收能力）
    - 第二次握手：服务端受到 SYN 请求报文之后，如果同意连接，会以自己的同步序列号SYN(服务端) = 1、初始化序列号 seq = y和确认序列号（期望下次收到的数据包）ack = x+ 1 以及确认号ACK = 1报文作为应答，服务器为SYN_Receive状态。
    - 第三次握手： 客户端接收到服务端的 SYN + ACK之后，知道可以下次可以发送了下一序列的数据包了，然后发送同步序列号 ack = y + 1和数据包的序列号 seq = x + 1以及确认号ACK = 1确认包作为应答，客户端转为established状态。
  - **第二种答案：**
    - 初始状态：客户端处于 closed(关闭)状态，服务器处于 listen(监听) 状态。
    - 第一次握手：建立连接时，客户端向服务器发送SYN包（seq=x），请求建立连接，等待确认
    - 第二次握手：服务端收到客户端的SYN包，回一个ACK包（ACK=x+1）确认收到，同时发送一个SYN包（seq=y）给客户端
    - 第三次握手：客户端收到SYN+ACK包，再回一个ACK包（ACK=y+1）告诉服务端已经收到
    - 三次握手完成，成功建立连接，开始传输数据

- [x] #### **15、四次挥手**

  - **第一种回答**
    - 初始化状态：客户端和服务端都在连接状态：
    - 第一次挥手：（第一次挥手无论是客户端还是服务端都可以发起，因为 TCP 是全双工的。）假如客户端发送的数据已经发送完毕，发送FIN = 1 告诉服务端，客户端所有数据已经全发完了，服务端你可以关闭接收了，但是如果你们服务端有数据要发给客户端，客户端照样可以接收的。此时**客户端发送FIN报文给服务器，进入FIN_WAIT_1状态**。
    - 第二次挥手：服务端接收到客户端的释放请求连接之后，知道客户端没有数据要发给自己了，然后服务端发送ACK = 1告诉客户端收到你发给我的信息，此时服务端处于 CLOSE_WAIT 等待关闭状态。（服务端先回应给客户端一声，我知道了，但服务端的发送数据能力即将等待关闭，于是接下来第三次就来了。）
    - 第三次挥手：此时服务端向客户端把所有的数据发送完了，然后发送一个FIN = 1，用于告诉客户端，服务端的所有数据发送完毕，客户端你也可以关闭接收数据连接了。此时服务端状态处于LAST_ACK状态，来等待确认客户端是否收到了自己的请求。（服务端等客户端回复是否收到呢，不收到的话，服务端不知道客户端是不是挂掉了还是咋回事呢，所以服务端不敢关闭自己的接收能力，于是第四次就来了。）
    - 第四次分手：此时如果客户端收到了服务端发送完的信息之后，就发送ACK = 1，告诉服务端，客户端已经收到了你的信息。有一个 2 MSL 的延迟等待。
  - **第二种回答**
    - 初始化状态：客户端和服务端都在连接状态：
    - 客户端发送FIN包（FIN=1)给服务端，告诉它自己的数据已经发送完毕，请求终止连接，此时客户端不发送数据，但还能接收数据，进入FIN_WAIT_1状态。
    - 服务端收到FIN包，回一个ACK包给客户端告诉它已经收到包了，此时还没有断开socket连接，而是等待剩下的数据传输完毕，此时服务器进入CLOSE_WAIT状态，客户端进入FIN_WAIT_2状态。
    - 服务端等待数据传输完毕后，向客户端发送FIN包，表明可以断开连接，等待客户端发送最后一个ACK，，服务器进入LAST_ACK状态。
    - 客户端收到后，回一个ACK包表明确认收到，等待2MSL时间，这的2MSL时间称为TIME_WAIT状态。确保服务端不再有数据发过来，然后彻底断开连接。

- [x] #### **16、为什么需要三次握手，两次不行吗？**

  - **进行三次握手的主要目的就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。**
  - 如果是用两次握手，则会出现下面这种情况：
    - 如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。

- [x] #### **17、挥手为什么需要四次？**

  - 第一种回答
    - 因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。
  - 第二种回答
    - 任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。

- [x] #### **18、ISN(Initial Sequence Number)是固定的吗？**

  - ISN不是固定的
  - **三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号**，因此 **ISN 是动态生成的**。

- [x] #### **19、半连接队列，全连接队列？**

  - 服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。
  - 当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

- [x] #### **20、简述** **TCP** **连接 和 关闭的状态转移**

![image-20220727171755931](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220727171755931.png)

![image-20220727165149033](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220727165149033.png)

- **上半部分是TCP三路握手过程的状态变迁，下半部分是TCP四次挥手过程的状态变迁。**
  - **CLOSED**：起始点，在超时或者连接关闭时候进入此状态，这并不是一个真正的状态，而是这个状态图的假想起点和终点。**
  - **LISTEN**：服务器端等待连接的状态。服务器经过 socket，bind，listen 函数之后进入此状态，开始监听客户端发过来的连接请求。此称为应用程序被动打开（等到客户端连接请求）。**
  - **SYN_SENT**：第一次握手发生阶段，客户端发起连接。客户端调用 connect，发送 SYN 给服务器端，然后进入 SYN_SENT 状态，等待服务器端确认（三次握手中的第二个报文）。如果服务器端不能连接，则直接进入CLOSED状态。**
  - **SYN_RCVD**：第二次握手发生阶段，跟 3 对应，这里是服务器端接收到了客户端的 SYN，此时服务器由 LISTEN 进入 SYN_RCVD状态，同时服务器端回应一个 ACK，然后再发送一个 SYN 即SYN+ACK 给客户端。状态图中还描绘了这样一种情况，当客户端在发送 SYN 的同时也收到服务器端的 SYN请求，即两个同时发起连接请求，那么客户端就会从 SYN_SENT 转换到 SYN_REVD 状态。
  - **ESTABLISHED**：第三次握手发生阶段，客户端接收到服务器端的 ACK 包（ACK，SYN）之后，也会发送一个 ACK 确认包，客户端进入 ESTABLISHED 状态，表明客户端这边已经准备好，但TCP需要两端都准备好才可以进行数据传输。服务器端收到客户端的 ACK 之后会从 SYN_RCVD 状态转移到 ESTABLISHED 状态，表明服务器端也准备好进行数据传输了。这样客户端和服务器端都是ESTABLISHED 状态，就可以进行后面的数据传输了。所以 ESTABLISHED 也可以说是一个数据传送状态。

- **下面看看TCP四次挥手过程的状态变迁。**
  - **FIN_WAIT_1**：第一次挥手。主动关闭的一方（执行主动关闭的一方既可以是客户端，也可以是服务器端，这里以客户端执行主动关闭为例），终止连接时，发送 FIN 给对方，然后等待对方返回ACK 。调用 close() 第一次挥手就进入此状态。
  - **CLOSE_WAIT**：接收到FIN 之后，被动关闭的一方进入此状态。具体动作是接收到 FIN，同时发送ACK。之所以叫 CLOSE_WAIT 可以理解为被动关闭的一方此时正在等待上层应用程序发出关闭连接指令。TCP关闭是全双工过程，这里客户端执行了主动关闭，被动方服务器端接收到FIN 后也需要调用 close 关闭，这个 CLOSE_WAIT 就是处于这个状态，等待发送 FIN，发送了FIN 则进入LAST_ACK 状态。
  - **FIN_WAIT_2**：主动端（这里是客户端）先执行主动关闭发送FIN，然后接收到被动方返回的 ACK后进入此状态。
  - **LAST_ACK**：被动方（服务器端）发起关闭请求，由状态2 进入此状态，具体动作是发送 FIN给对方，同时在接收到ACK 时进入CLOSED状态。
  - **CLOSING**：两边同时发起关闭请求时（即主动方发送FIN，等待被动方返回ACK，同时被动方也发送了FIN，主动方接收到了FIN之后，发送ACK给被动方），主动方会由FIN_WAIT_1 进入此状态，等待被动方返回ACK。 
  - **TIME_WAIT**：从状态变迁图会看到，四次挥手操作最后都会经过这样一个状态然后进入CLOSED状态。


- [x] #### **21、简述TCP的TIME_WAIT，为什么需要有这个状态**

- [ ] TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。

- [ ] 对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。

- [ ] 理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。

- [x] #### **22、简述什么是MSL，为什么客户端连接要等待2MSL的时间才能完全关闭?**

  - MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

  - 为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。
  - 两个理由：
    - **① 保证客户端发送的最后一个ACK报文段能够到达服务端。**
      - 这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。
    - **② 防止“已失效的连接请求报文段”出现在本连接中。**
      - 客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。

- [x] #### **23、对于FINWAIT2，CLOSEWAIT状态和TIMEWAIT状态？你知道多少?**

  - **FIN_WAIT_2：半关闭状态。**
    - 发送断开请求一方还有接收数据能力，但已经没有发送数据能力。
  - **CLOSE_WAIT状态：**
    - 被动关闭连接一方接收到FIN包会立即回应ACK包表示已接收到断开请求。
    - 被动关闭连接一方如果还有剩余数据要发送就会进入CLOSE_WAIT状态。
  - **TIME_WAIT状态：又叫2MSL等待状态。**
    - 如果客户端直接进入CLOSED状态，如果服务端没有接收到最后一次ACK包会在超时之后重新再发FIN包，此时因为客户端已经CLOSED，所以服务端就不会收到ACK而是收到RST。所以**TIME_WAIT状态目的是防止最后一次握手数据没有到达对方而触发重传FIN准备的。**
    - 在2MSL时间内，同一个socket不能再被使用，否则有可能会和旧连接数据混淆（如果新连接和旧连接的socket相同的话）。

- [x] #### **24、服务器出现大量close_wait的连接的原因是什么？有什么解决方法？**

  - close_wait状态是在TCP四次挥手的时候收到FIN但是没有发送自己的FIN时出现的，服务器出现大量的close_wait情况有两种：
    - **服务器内部业务处理占用太多时间**，都没能处理完业务，或还有数据需要发送，或者**服务器的业务逻辑有问题，没有执行close方法。**
    - 服务器的父进程派生出子进程，子进程继承socket，收到FIN的时候子进程处理但父进程没有处理该信号，导致socket引用不为0而无法回收。
  - **处理方法：**
    - 停止应用程序
    - 修改程序里的bug	

- [x] #### **25、TCP粘包问题是什么？你会如何去解决它？**

  - TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。
  - 产生粘包的原因：
    - 由TCP连接复用造成的粘包问题。
    - 因为TCP默认会使用Nagle算法，此算法会导致粘包问题。
    - 数据包过大造成的粘包问题。
    - 流量控制，拥塞控制也可能导致粘包。
    - 接收方不及时接收缓冲区的包，造成多个包接收
  - 解决方法：
    - Nagle算法问题导致的，需要结合应用场景适当关闭该算法
    - 尾部标记序列。通过特殊标识符表示数据包的边界，例如\n\r，\t，或者一些隐藏字符。
    - 头部标记分步接收。在TCP报文的头部加上表示数据长度。
    - 应用层发送数据时定长发送。

  #### **26、简述TCP慢启动**

  - **慢启动**（Slow Start），是传输控制协议（TCP）使用的一种阻塞控制机制。慢启动也叫做指数增长期。慢启动是指每次TCP接收窗口收到确认时都会增长。增加的大小就是已确认段的数目。这种情况一直保持到要么没有收到一些段，要么窗口大小到达预先定义的阈值。如果发生丢失事件，TCP就认为这是网络阻塞，就会采取措施减轻网络拥挤。一旦发生丢失事件或者到达阈值，TCP就会进入线性增长阶段。这时，每经过一个RTT窗口增长一个段。

  #### **27、说下TCP如何保证有序**

  - 主机每次发送数据时，TCP就给每个数据包分配一个序列号并且在一个特定的时间内等待接收主机对分配的这个序列号进行确认，如果发送主机在一个特定时间内没有收到接收主机的确认，则发送主机会重传此数据包。接收主机利用序列号对接收的数据进行确认，以便检测对方发送的数据是否有丢失或者乱序等，接收主机一旦收到已经顺序化的数据，它就将这些数据按正确的顺序重组成数据流并传递到高层进行处理。
  - 具体步骤如下：
    1. 为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区；
    2. 并为每个已发送的数据包启动一个超时定时器；
    3. 如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区; 
    4. 否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。
    5. 接收方收到数据包后，先进行CRC校验，**如果正确则把数据交给上层协议**，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。

  #### **28、拥塞控制原理听说过吗？**

  - **拥塞控制目的是防止数据被过多注入到网络中导致网络资源（路由器、交换机等）过载。**因为拥塞控制涉及网络链路全局，所以属于全局控制。控制拥塞使用拥塞窗口。
  - TCP拥塞控制算法：
    - 慢开始 & 拥塞避免：先试探网络拥塞程度再逐渐增大拥塞窗口。假设窗口长度为d，收到一个确认就加1，正好收到了d个确认，所以一共加d，正好是翻倍，直到达到阀值ssthresh，这部分是慢开始过程。达到阀值后每次以一个MSS为单位增长拥塞窗口大小，当发生拥塞（超时未收到确认），将阀值减为原先一半，继续执行增加，这个过程为拥塞避免。
    - 快速重传 & 快速恢复
    - 最终拥塞窗口会收敛于稳定值。

  #### **29、说说TCP常见的拥塞控制算法有哪些**

  1. TCP Tahoe/Reno
     - 最初的实现，包括慢启动、拥塞避免两个部分。基于重传超时（retransmission timeout/RTO）和重复确认为条件判断是否发生了丢包。
     - 两者的区别在于：
       - Tahoe算法下如果收到三次重复确认（3个ACK），就进入快重传立即重发丢失的数据包，同时将慢启动阈值设置为当前拥塞窗口的一半，将拥塞窗口设置为1MSS，进入慢启动状态；
       - Reno算法如果收到三次重复确认（3个ACK），就进入快重传，但不进入慢启动状态，而是直接将拥塞窗口减半，进入拥塞控制阶段，这称为“快恢复”。 
       - Tahoe和Reno算法在出现RTO时的措施一致，都是将拥塞窗口降为1个MSS，然后进入慢启动阶段。
     - **慢启动算法 – Slow Start**
       - 所谓慢启动，也就是TCP连接刚建立，一点一点地提速，试探一下网络的承受能力，以免直接扰乱了网络通道的秩序。
       - 连接建好的开始先初始化拥塞窗口cwnd大小为1，表明可以传一个MSS大小的数据。
       - 每当收到一个ACK，cwnd大小加一，呈线性上升。
       - 每当过了一个往返延迟时间RTT(Round-Trip Time)，cwnd大小直接翻倍，乘以2，呈指数让升。
       - 还有一个ssthresh（slow start threshold），是一个上限，当cwnd >= ssthresh时，就会进入“拥塞避免算法”
     - **拥塞避免算法 – Congestion Avoidance**
       - 如同前边说的，当拥塞窗口大小cwnd大于等于慢启动阈值ssthresh后，就进入拥塞避免算法。算法如下：
         - 收到一个ACK，则cwnd = cwnd + 1 / cwnd
         - 每当过了一个往返延迟时间RTT，cwnd大小加一。
         - 过了慢启动阈值后，拥塞避免算法可以避免窗口增长过快导致窗口拥塞，而是缓慢的增加调整到网络的最佳值。

  2. TCP BBR（Bottleneck Bandwidth and Round-trip propagation time）
     - BBR是由Google设计，于2016年发布的拥塞算法。**以往大部分拥塞算法是基于丢包来作为降低传输速率的信号，而BBR则基于模型主动探测。**该算法使用网络最近出站数据分组当时的最大带宽和往返时间来建立网络的显式模型。数据包传输的每个累积或选择性确认用于生成记录在数据包传输过程和确认返回期间的时间内所传送数据量的采样率。该算法认为随着网络接口控制器逐渐进入千兆速度时，分组丢失不应该被认为是识别拥塞的主要决定因素，所以基于模型的拥塞控制算法能有更高的吞吐量和更低的延迟，可以用BBR来替代其他流行的拥塞算法，例如CUBIC。

  #### **30、TCP四大拥塞控制算法？**

  - 拥塞控制主要是四个算法：
    - 1）慢启动
    - 2）拥塞避免
    - 3）快速重传
    - 4）快速恢复。
  - **慢启动算法 – Slow Start**
    - 所谓慢启动，也就是TCP连接刚建立，一点一点地提速，试探一下网络的承受能力，以免直接扰乱了网络通道的秩序。
    - 连接建好的开始先初始化拥塞窗口cwnd大小为1，表明可以传一个MSS大小的数据。
    - 每当收到一个ACK，cwnd大小加一，呈线性上升。
    - 每当过了一个往返延迟时间RTT(Round-Trip Time)，cwnd大小直接翻倍，乘以2，呈指数让升。
    - 还有一个ssthresh（slow start threshold），是一个上限，当cwnd >= ssthresh时，就会进入“拥塞避免算法”
  - **拥塞避免算法 – Congestion Avoidance**
    - 如同前边说的，当拥塞窗口大小cwnd大于等于慢启动阈值ssthresh后，就进入拥塞避免算法。算法如下：
      - 收到一个ACK，则cwnd = cwnd + 1 / cwnd
      - 每当过了一个往返延迟时间RTT，cwnd大小加一。
      - 过了慢启动阈值后，拥塞避免算法可以避免窗口增长过快导致窗口拥塞，而是缓慢的增加调整到网络的最佳值。
  - **拥塞发生状态时的算法**
    - 一般来说，TCP拥塞控制默认认为网络丢包是由于网络拥塞导致的，所以一般的TCP拥塞控制算法以丢包为网络进入拥塞状态的信号。**对于丢包有两种判定方式，一种是超时重传RTO[Retransmission Timeout]超时，另一个是收到三个重复确认ACK。**
    - 超时重传是TCP协议保证数据可靠性的一个重要机制，其原理是在发送一个数据以后就开启一个计时器，在一定时间内如果没有得到发送数据报的ACK报文，那么就重新发送数据，直到发送成功为止。
    - 但是如果发送端接收到3个以上的重复ACK，TCP就意识到数据发生丢失，需要重传。这个机制不需要等到重传定时器超时，所以叫 做**快速重传**，**而快速重传后没有使用慢启动算法，而是拥塞避免算法，所以这又叫做快速恢复算法**。
    - 超时重传RTO[Retransmission Timeout]超时，TCP会重传数据包。TCP认为这种情况比较糟糕，反应也比较强烈：
    - 由于发生丢包，将慢启动阈值ssthresh设置为当前cwnd的一半，即ssthresh = cwnd / 2.cwnd重置为1，进入慢启动。
    - 最为早期的TCP Tahoe算法就只使用上述处理办法，但是由于一丢包就一切重来，导致cwnd又重置为1，十分不利于网络数据的稳定传递。所以，TCP Reno算法进行了优化。当收到三个重复确认ACK时，TCP开启快速重传Fast Retransmit算法，而不用等到RTO超时再进行重传：
      - cwnd大小缩小为当前的一半
      - ssthresh设置为缩小后的cwnd大小
      - 然后进入快速恢复算法Fast Recovery。
  - **快速恢复算法 – Fast Recovery**
    - TCP Tahoe是早期的算法，所以没有快速恢复算法，而Reno算法有。在进入快速恢复之前，cwnd和ssthresh已经被更改为原有cwnd的一半。快速恢复算法的逻辑如下：
      - cwnd = cwnd + 3 MSS，加3MSS的原因是因为收到3个重复的ACK。重传DACKs指定的数据包。如果再收到DACKs，那么cwnd大小增加一。如果收到新的ACK，表明重传的包成功了，那么退出快速恢复算法。将cwnd设置为ssthresh，然后进入拥塞避免算法。

- [x] #### 31、**如何区分流量控制和拥塞控制？**

  - 流量控制属于通信双方协商，拥塞控制涉及通信链路全局。
  - 流量控制需要通信双方各维护一个发送窗、接受窗，对任意一方，接收窗大小由自身决定，发送窗的大小由接收方响应的TCP报文段中窗口值决定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后自适应调整实际最终发送窗口=min{流量发送窗口，拥塞窗口}	

- [x] #### **32、你了解流量控制原理吗？**

  - **是接收方通过TCP头窗口字段告知发送方本方可接收的最大数据量，用以解决发送速率过快导致接收方不能接收的问题。所以流量控制是点对点控制。**
  - TCP是双工协议，双方可以同时通信，所以发送方接收方各自维护一个发送窗和接收窗。
  - 发送窗：用来限制发送方可以发送的数据大小，其中发送窗口的大小由接收端返回的TCP报文段中窗口字段来控制，接收方通过此字段告知发送方自己的缓冲（受系统、硬件等限制）大小。
  - 接收窗：用来标记可以接收的数据大小。
  - TCP是流数据，发送出去的数据流可以被分为以下四部分：已发送且被确认部分 | 已发送未被确认部分 | 未发送但可发送部分 | 不可发送部分，其中发送窗 = 已发送未确认部分 + 未发但可发送部分。接收到的数据流可分为：已接收 | 未接收但准备接收 | 未接收不准备接收。接收窗 = 未接收但准备接收部分。
  - 发送窗内数据只有当接收到接收端某段发送数据的ACK响应时才移动发送窗，左边缘紧贴刚被确认的数据。接收窗也只有接收到数据且最左侧连续时才移动接收窗口。

- [x] #### 33、**TCP 利用滑动窗口实现流量控制的机制？**

  - 流量控制是为了控制发送方发送速率，保证接收方来得及接收。TCP 利用滑动窗口实现流量控制。
  - TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据。例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。

- [x] #### **34、简述** **TCP** **超时重传**

  - **TCP可靠性中最重要的一个机制是处理数据超时和重传。**TCP协议要求在发送端每发送一个报文段，就启动一个定时器并等待确认信息；接收端成功接收新数据后返回确认信息。若在定时器超时前数据未能被确认，TCP就认为报文段中的数据已丢失或损坏，需要对报文段中的数据重新组织和重传。

- [x] #### **35、简述** **TCP** **滑动窗口以及重传机制**

  - **滑动窗口协议是传输层进行流控的一种措施**，接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的。TCP的滑动窗口解决了端到端的流量控制问题，允许接受方对传输进行限制，直到它拥有足够的缓冲空间来容纳更多的数据。
  - TCP在发送数据时会设置一个计时器，若到计时器超时仍未收到数据确认信息，则会引发相应的超时或基于计时器的重传操作，计时器超时称为**重传超时（RTO）** 。另一种方式的重传称为快速重传，通常发生在没有延时的情况下。若TCP累积确认无法返回新的ACK，或者当ACK包含的选择确认信息（SACK）表明出现失序报文时，快速重传会推断出现丢包，需要重传。

- [x] #### **36、说说滑动窗口过小会怎样**

  - 我们可以假设窗口的大小是1，也是就每次只能发送一个数据，并且发送方只有接受方对这个数据进行确认了以后才能发送下一个数据。如果说窗口过小，那么当传输比较大的数据的时候需要不停的对数据进行确认，这个时候就会造成很大的延迟。

- [x] #### **37、说说如果三次握手时候每次握手信息对方没收到会怎么样，分情况介绍**

  1. 如果第一次握手消息丢失，那么请求方不会得到ack消息，超时后进行重传
  2. 如果第二次握手消息丢失，那么请求方不会得到ack消息，超时后进行重传
  3. **如果第三次握手消息丢失，那么Server 端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便Client重新发送ACK包。而Server重发SYN+ACK包的次数，可以设置/proc/sys/net/ipv4/tcp_synack_retries修改，默认值为5.如果重发指定次数之后，仍然未收到 client 的ACK应答，那么一段时间后，Server自动关闭这个连接。**client 一般是通过 connect() 函数来连接服务器的，而connect()是在 TCP的三次握手的第二次握手完成后就成功返回值。也就是说 client 在接收到 SYN+ACK包，它的TCP连接状态就为 established（已连接），表示该连接已经建立。那么如果 第三次握手中的ACK包丢失的情况下，Client 向server端发送数据，Server端将以 RST包响应，方能感知到Server的错误。

- [x] #### **38、TCP** **与** **UDP** **在网络协议中的哪一层？各自的应用领域？**

  - TCP和UDP协议都是**传输层**协议。
  - 应用领域：
    - 由于TCP提供可靠交付和有序性的保证，它是最适合需要高可靠并且对传输时间要求不高的应用。
    - UDP是更适合的应用程序需要快速，高效的传输的应用，如游戏。
    - UDP是无状态的性质，在服务器端需要对大量客户端产生的少量请求进行应答的应用中是非常有用的。
    - 在实践中，TCP被用于金融领域，如FIX协议是一种基于TCP的协议，而UDP是大量使用在游戏和娱乐场所。

- [x] #### 39、基于TCP/UDP的协议有哪些？

  - 基于TCP协议的：Telnet，FTP以及SMTP协议。
  - 基于UDP协议的：DHCP、DNS、SNMP、TFTP、BOOTP。

- [x] #### 40、**可以解释一下RTO，RTT和超时重传分别是什么吗？**

  - 超时重传：发送端发送报文后若长时间未收到确认的报文则需要重发该报文。可能有以下几种情况：发送的数据没能到达接收端，所以对方没有响应。接收端接收到数据，但是ACK报文在返回过程中丢失。接收端拒绝或丢弃数据。
  - **RTO：从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的时间。就是重传间隔。**通常每次重传RTO是前一次重传间隔的两倍，计量单位通常是RTT。例：1RTT，2RTT，4RTT，8RTT......重传次数到达上限之后停止重传。
  - **RTT：数据从发送到接收到对方响应之间的时间间隔，即数据报在网络中一个往返用时。大小不稳定。**

- [x] #### **41、说说从系统层面上，UDP 如何保证尽量可靠？**

  1. UDP仅提供了最基本的数据传输功能，至于传输时连接的建立和断开、传输可靠性的保证这些UDP统统不关心，而是把这些问题抛给了UDP上层的应用层程序去处理，自己仅提供传输层协议的最基本功能。
  2. 最简单的方式是在应用层模仿传输层TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。
     - 添加seq/ack机制，确保数据发送到对端
     - 添加发送和接收缓冲区，主要是用户超时重传。
     - 添加超时重传机制。

- [x] #### 42、TCP **协议的延迟** **ACK** **和累计应答**

  - 延迟应答指的是：TCP在接收到对端的报文后，并不会立即发送ack，而是等待一段时间发送ack，以便将ack和要发送的数据一块发送。当然ack不能无限延长，否则对端会认为包超时而造成报文重传。linux采用动态调节算法来确定延时的时间。
  - 累计应答指的是：为了保证**顺序性**，每一个包都有一个**ID**（序号），在建立连接的时候，会商定起始的ID是多少，然后按照ID一个个发送。而为了保证不丢包，对应发送的包都要进行应答，但不是一个个应答，而是会**应答某个之前的ID**，该模式称为**累计应答 **

- [x] #### **43、服务器怎么判断客户端断开了连接**

  - 检测连接是否丢失的方法大致有两种：**keepalive**和**heart-beat**
  - （tcp内部机制）采用keepalive，它会先要求此连接一定时间没有活动（一般是几个小时），然后发出数据段，经过多次尝试后（每次尝试之间也有时间间隔），如果仍没有响应，则判断连接中断。可想而知，整个**周期需要很长**的时间。
  - （应用层实现）一个简单的heart-beat实现一般测试连接是否中断采用的时间间隔都比较短，可以**很快的决定连接是否中断**。并且，由于是在应用层实现，因为可以自行决定当判断连接中断后应该采取的行为，而keepalive在判断连接失败后只会将连接丢弃。

- [ ] **说说端到端，点到点的区别**

  - **端到端通信是针对传输层来说的**，传输层为网络中的主机提供端到端的通信。因为无论tcp还是udp协议，都要负责把上层交付的数据从发送端传输到接收端，不论其中间跨越多少节点。只不过tcp比较可靠而udp不可靠而已。所以称之为端到端，也就是从发送端到接收端。
  - **端到端的优点：**
    - 链路建立之后，发送端知道接收端一定能收到，而且经过中间交换设备时不需要进行存储转发，因此传输延迟小。
  - **端到端传输的缺点：**
    - 直到接收端收到数据为止，发送端的设备一直要参与传输。如果整个传输的延迟很长，那么对发送端的设备造成很大的浪费。
    - 如果接收设备关机或故障，那么端到端传输不可能实现。
  - **点到点通信是针对数据链路层或网络层来说的**，因为数据链路层只负责直接相连的两个节点之间的通信，一个节点的数据链路层接受ip层数据并封装之后，就把数据帧从链路上发送到与其相邻的下一个节点。 点对点是基于MAC地址和或者IP地址，是指一个设备发数据给与该这边直接连接的其他设备，这台设备又在合适的时候将数据传递给与它相连的下一个设备，通过一台一台直接相连的设备把数据传递到接收端。
  - **点到点的优点：**
    - 发送端设备送出数据后，它的任务已经完成，不需要参与整个传输过程，这样不会浪费发送端设备的资源。
    - 即使接收端设备关机或故障，点到点传输也可以采用存储转发技术进行缓冲。
  - **点到点的缺点：**
    - 点到点传输的缺点是发送端发出数据后，不知道接收端能否收到或何时能收到数据。在一个网络系统的不同分层中，可能用到端到端传输，也可能用到点到点传输。如Internet网，IP及以下各层采用点到点传输，4层以上采用端到端传输。

- [x] #### **45、说说** **TCP** **可靠性保证**

  - TCP主要提供了检验和、序列号/确认应答、超时重传、最大消息长度、滑动窗口控制等方法实现了可靠性传输
  - **检验和**
    - 通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃TCP段，重新发送。TCP在计算检验和时，会在TCP首部加上一个12字节的伪首部。检验和总共计算3部分：TCP首部、TCP数据、TCP伪首部
    - <img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220730131407796.png" alt="image-20220730131407796" style="zoom:80%;" />
  - **序列号/确认应答**
    - 这个机制类似于问答的形式。比如在课堂上老师会问你“明白了吗？”，假如你没有隔一段时间没有回应或者你说不明白，那么老师就会重新讲一遍。其实计算机的确认应答机制也是一样的，发送端发送信息给接收端，接收端会回应一个包，这个包就是应答包。
    - <img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220730131522622.png" alt="image-20220730131522622" style="zoom:80%;" />
    - 上述过程中，只要发送端有一个包传输，接收端没有回应确认包（ACK包），都会重发。或者接收端的应答包，发送端没有收到也会重发数据。这就可以保证数据的完整性。
  - **最大消息长度**
    - 在建立TCP连接的时候，双方约定一个最大的长度（MSS）作为发送的单位，重传的时候也是以这个单位来进行重传。理想的情况下是该长度的数据刚好不被网络层分块。
    - <img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220730131625963.png" alt="image-20220730131625963" style="zoom:80%;" />
  - **滑动窗口控制**
    - 我们上面提到的超时重传的机制存在效率低下的问题，发送一个包到发送下一个包要经过一段时间才可以。所以我们就想着能不能不用等待确认包就发送下一个数据包呢？这就提出了一个滑动窗口的概念。
    - <img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220730131716903.png" alt="image-20220730131716903" style="zoom:80%;" />
    - 窗口的大小就是在无需等待确认包的情况下，发送端还能发送的最大数据量。这个机制的实现就是使用了大量的缓冲区，通过对多个段进行确认应答的功能。通过下一次的确认包可以判断接收端是否已经接收到了数据，如果已经接收了就从缓冲区里面删除数据。在窗口之外的数据就是还未发送的和对端已经收到的数据。那么发送端是怎么样判断接收端有没有接收到数据呢？或者怎么知道需要重发的数据有哪些呢？通过下面这个图就知道了
    - <img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220730131809356.png" alt="image-20220730131809356" style="zoom:80%;" />
    - 如上图，接收端在没有收到自己所期望的序列号数据之前，会对之前的数据进行重复确认。发送端在收到某个应答包之后，又连续3次收到同样的应答包，则数据已经丢失了，需要重发。
  - **拥塞控制**
    - 窗口控制解决了 两台主机之间因传送速率而可能引起的丢包问题，在一方面保证了TCP数据传送的可靠性。然而如果网络非常拥堵，此时再发送数据就会加重网络负担，那么发送的数据段很可能超过了最大生存时间也没有到达接收方，就会产生丢包问题。为此TCP引入慢启动机制，先发出少量数据，就像探路一样，先摸清当前的网络拥堵状态后，再决定按照多大的速度传送数据。
    - 发送开始时定义拥塞窗口大小为1；每次收到一个ACK应答，拥塞窗口加1；而在每次发送数据时，发送窗口取拥塞窗口与接送段接收窗口最小者。
    - 慢启动：在启动初期以指数增长方式增长；设置一个慢启动的阈值，当以指数增长达到阈值时就停止指数增长，按照线性增长方式增加至拥塞窗口；线性增长达到网络拥塞时立即把拥塞窗口置回1，进行新一轮的“慢启动”，同时新一轮的阈值变为原来的一半。
    - <img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220730132119858.png" alt="image-20220730132119858" style="zoom:80%;" />

  
